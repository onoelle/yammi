<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>glib.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>glib.h</h1><div class="fragment"><pre>00001 <font class="comment">/* GLIB - Library of useful routines for C programming</font>
00002 <font class="comment"> * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * This library is free software; you can redistribute it and/or</font>
00005 <font class="comment"> * modify it under the terms of the GNU Library General Public</font>
00006 <font class="comment"> * License as published by the Free Software Foundation; either</font>
00007 <font class="comment"> * version 2 of the License, or (at your option) any later version.</font>
00008 <font class="comment"> *</font>
00009 <font class="comment"> * This library is distributed in the hope that it will be useful,</font>
00010 <font class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00011 <font class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00012 <font class="comment"> * Library General Public License for more details.</font>
00013 <font class="comment"> *</font>
00014 <font class="comment"> * You should have received a copy of the GNU Library General Public</font>
00015 <font class="comment"> * License along with this library; if not, write to the</font>
00016 <font class="comment"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</font>
00017 <font class="comment"> * Boston, MA 02111-1307, USA.</font>
00018 <font class="comment"> */</font>
00019 
00020 <font class="comment">/*</font>
00021 <font class="comment"> * Modified by the GLib Team and others 1997-1999.  See the AUTHORS</font>
00022 <font class="comment"> * file for a list of people on the GLib Team.  See the ChangeLog</font>
00023 <font class="comment"> * files for a list of changes.  These files are distributed with</font>
00024 <font class="comment"> * GLib at ftp://ftp.gtk.org/pub/gtk/. </font>
00025 <font class="comment"> */</font>
00026 
00027 <font class="preprocessor">#ifndef __G_LIB_H__</font>
00028 <font class="preprocessor"></font><font class="preprocessor">#define __G_LIB_H__</font>
00029 <font class="preprocessor"></font>
00030 <font class="comment">/* system specific config file glibconfig.h provides definitions for</font>
00031 <font class="comment"> * the extrema of many of the standard types. These are:</font>
00032 <font class="comment"> *</font>
00033 <font class="comment"> *  G_MINSHORT, G_MAXSHORT</font>
00034 <font class="comment"> *  G_MININT, G_MAXINT</font>
00035 <font class="comment"> *  G_MINLONG, G_MAXLONG</font>
00036 <font class="comment"> *  G_MINFLOAT, G_MAXFLOAT</font>
00037 <font class="comment"> *  G_MINDOUBLE, G_MAXDOUBLE</font>
00038 <font class="comment"> *</font>
00039 <font class="comment"> * It also provides the following typedefs:</font>
00040 <font class="comment"> *</font>
00041 <font class="comment"> *  gint8, guint8</font>
00042 <font class="comment"> *  gint16, guint16</font>
00043 <font class="comment"> *  gint32, guint32</font>
00044 <font class="comment"> *  gint64, guint64</font>
00045 <font class="comment"> *</font>
00046 <font class="comment"> * It defines the G_BYTE_ORDER symbol to one of G_*_ENDIAN (see later in</font>
00047 <font class="comment"> * this file). </font>
00048 <font class="comment"> *</font>
00049 <font class="comment"> * And it provides a way to store and retrieve a `gint' in/from a `gpointer'.</font>
00050 <font class="comment"> * This is useful to pass an integer instead of a pointer to a callback.</font>
00051 <font class="comment"> *</font>
00052 <font class="comment"> *  GINT_TO_POINTER(i), GUINT_TO_POINTER(i)</font>
00053 <font class="comment"> *  GPOINTER_TO_INT(p), GPOINTER_TO_UINT(p)</font>
00054 <font class="comment"> *</font>
00055 <font class="comment"> * Finally, it provide the following wrappers to STDC functions:</font>
00056 <font class="comment"> *</font>
00057 <font class="comment"> *  g_ATEXIT</font>
00058 <font class="comment"> *    To register hooks which are executed on exit().</font>
00059 <font class="comment"> *    Usually a wrapper for STDC atexit.</font>
00060 <font class="comment"> *</font>
00061 <font class="comment"> *  void *g_memmove(void *dest, const void *src, guint count);</font>
00062 <font class="comment"> *    A wrapper for STDC memmove, or an implementation, if memmove doesn't</font>
00063 <font class="comment"> *    exist.  The prototype looks like the above, give or take a const,</font>
00064 <font class="comment"> *    or size_t.</font>
00065 <font class="comment"> */</font>
00066 <font class="preprocessor">#include &lt;glibconfig.h&gt;</font>
00067 
00068 <font class="comment">/* include varargs functions for assertment macros</font>
00069 <font class="comment"> */</font>
00070 <font class="preprocessor">#include &lt;stdarg.h&gt;</font>
00071 
00072 <font class="comment">/* optionally feature DMALLOC memory allocation debugger</font>
00073 <font class="comment"> */</font>
00074 <font class="preprocessor">#ifdef USE_DMALLOC</font>
00075 <font class="preprocessor"></font><font class="preprocessor">#include "dmalloc.h"</font>
00076 <font class="preprocessor">#endif</font>
00077 <font class="preprocessor"></font>
00078 
00079 <font class="preprocessor">#ifdef NATIVE_WIN32</font>
00080 <font class="preprocessor"></font>
00081 <font class="comment">/* On native Win32, directory separator is the backslash, and search path</font>
00082 <font class="comment"> * separator is the semicolon.</font>
00083 <font class="comment"> */</font>
00084 <font class="preprocessor">#define G_DIR_SEPARATOR '\\'</font>
00085 <font class="preprocessor"></font><font class="preprocessor">#define G_DIR_SEPARATOR_S "\\"</font>
00086 <font class="preprocessor"></font><font class="preprocessor">#define G_SEARCHPATH_SEPARATOR ';'</font>
00087 <font class="preprocessor"></font><font class="preprocessor">#define G_SEARCHPATH_SEPARATOR_S ";"</font>
00088 <font class="preprocessor"></font>
00089 <font class="preprocessor">#else  </font><font class="comment">/* !NATIVE_WIN32 */</font>
00090 
00091 <font class="preprocessor">#ifndef __EMX__</font>
00092 <font class="preprocessor"></font><font class="comment">/* Unix */</font>
00093 
00094 <font class="preprocessor">#define G_DIR_SEPARATOR '/'</font>
00095 <font class="preprocessor"></font><font class="preprocessor">#define G_DIR_SEPARATOR_S "/"</font>
00096 <font class="preprocessor"></font><font class="preprocessor">#define G_SEARCHPATH_SEPARATOR ':'</font>
00097 <font class="preprocessor"></font><font class="preprocessor">#define G_SEARCHPATH_SEPARATOR_S ":"</font>
00098 <font class="preprocessor"></font>
00099 <font class="preprocessor">#else</font>
00100 <font class="preprocessor"></font><font class="comment">/* EMX/OS2 */</font>
00101 
00102 <font class="preprocessor">#define G_DIR_SEPARATOR '/'</font>
00103 <font class="preprocessor"></font><font class="preprocessor">#define G_DIR_SEPARATOR_S "/"</font>
00104 <font class="preprocessor"></font><font class="preprocessor">#define G_SEARCHPATH_SEPARATOR ';'</font>
00105 <font class="preprocessor"></font><font class="preprocessor">#define G_SEARCHPATH_SEPARATOR_S ";"</font>
00106 <font class="preprocessor"></font>
00107 <font class="preprocessor">#endif</font>
00108 <font class="preprocessor"></font>
00109 <font class="preprocessor">#endif </font><font class="comment">/* !NATIVE_WIN32 */</font>
00110 
00111 <font class="preprocessor">#ifdef __cplusplus</font>
00112 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="stringliteral">"C"</font> {
00113 <font class="preprocessor">#endif </font><font class="comment">/* __cplusplus */</font>
00114 
00115 
00116 <font class="comment">/* Provide definitions for some commonly used macros.</font>
00117 <font class="comment"> *  Some of them are only provided if they haven't already</font>
00118 <font class="comment"> *  been defined. It is assumed that if they are already</font>
00119 <font class="comment"> *  defined then the current definition is correct.</font>
00120 <font class="comment"> */</font>
00121 <font class="preprocessor">#ifndef NULL</font>
00122 <font class="preprocessor"></font><font class="preprocessor">#define NULL    ((void*) 0)</font>
00123 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00124 <font class="preprocessor"></font>
00125 <font class="preprocessor">#ifndef FALSE</font>
00126 <font class="preprocessor"></font><font class="preprocessor">#define FALSE   (0)</font>
00127 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00128 <font class="preprocessor"></font>
00129 <font class="preprocessor">#ifndef TRUE</font>
00130 <font class="preprocessor"></font><font class="preprocessor">#define TRUE    (!FALSE)</font>
00131 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00132 <font class="preprocessor"></font>
00133 <font class="preprocessor">#undef  MAX</font>
00134 <font class="preprocessor"></font><font class="preprocessor">#define MAX(a, b)  (((a) &gt; (b)) ? (a) : (b))</font>
00135 <font class="preprocessor"></font>
00136 <font class="preprocessor">#undef  MIN</font>
00137 <font class="preprocessor"></font><font class="preprocessor">#define MIN(a, b)  (((a) &lt; (b)) ? (a) : (b))</font>
00138 <font class="preprocessor"></font>
00139 <font class="preprocessor">#undef  ABS</font>
00140 <font class="preprocessor"></font><font class="preprocessor">#define ABS(a)     (((a) &lt; 0) ? -(a) : (a))</font>
00141 <font class="preprocessor"></font>
00142 <font class="preprocessor">#undef  CLAMP</font>
00143 <font class="preprocessor"></font><font class="preprocessor">#define CLAMP(x, low, high)  (((x) &gt; (high)) ? (high) : (((x) &lt; (low)) ? (low) : (x)))</font>
00144 <font class="preprocessor"></font>
00145 
00146 <font class="comment">/* Define G_VA_COPY() to do the right thing for copying va_list variables.</font>
00147 <font class="comment"> * glibconfig.h may have already defined G_VA_COPY as va_copy or __va_copy.</font>
00148 <font class="comment"> */</font>
00149 <font class="preprocessor">#if !defined (G_VA_COPY)</font>
00150 <font class="preprocessor"></font><font class="preprocessor">#  if defined (__GNUC__) &amp;&amp; defined (__PPC__) &amp;&amp; (defined (_CALL_SYSV) || defined (_WIN32))</font>
00151 <font class="preprocessor"></font><font class="preprocessor">#  define G_VA_COPY(ap1, ap2)     (*(ap1) = *(ap2))</font>
00152 <font class="preprocessor"></font><font class="preprocessor">#  elif defined (G_VA_COPY_AS_ARRAY)</font>
00153 <font class="preprocessor"></font><font class="preprocessor">#  define G_VA_COPY(ap1, ap2)     g_memmove ((ap1), (ap2), sizeof (va_list))</font>
00154 <font class="preprocessor"></font><font class="preprocessor">#  else </font><font class="comment">/* va_list is a pointer */</font>
00155 <font class="preprocessor">#  define G_VA_COPY(ap1, ap2)     ((ap1) = (ap2))</font>
00156 <font class="preprocessor"></font><font class="preprocessor">#  endif </font><font class="comment">/* va_list is a pointer */</font>
00157 <font class="preprocessor">#endif </font><font class="comment">/* !G_VA_COPY */</font>
00158 
00159 
00160 <font class="comment">/* Provide convenience macros for handling structure</font>
00161 <font class="comment"> * fields through their offsets.</font>
00162 <font class="comment"> */</font>
00163 <font class="preprocessor">#define G_STRUCT_OFFSET(struct_type, member)    \</font>
00164 <font class="preprocessor">    ((gulong) ((gchar*) &amp;((struct_type*) 0)-&gt;member))</font>
00165 <font class="preprocessor"></font><font class="preprocessor">#define G_STRUCT_MEMBER_P(struct_p, struct_offset)   \</font>
00166 <font class="preprocessor">    ((gpointer) ((gchar*) (struct_p) + (gulong) (struct_offset)))</font>
00167 <font class="preprocessor"></font><font class="preprocessor">#define G_STRUCT_MEMBER(member_type, struct_p, struct_offset)   \</font>
00168 <font class="preprocessor">    (*(member_type*) G_STRUCT_MEMBER_P ((struct_p), (struct_offset)))</font>
00169 <font class="preprocessor"></font>
00170 
00171 <font class="comment">/* inlining hassle. for compilers that don't allow the `inline' keyword,</font>
00172 <font class="comment"> * mostly because of strict ANSI C compliance or dumbness, we try to fall</font>
00173 <font class="comment"> * back to either `__inline__' or `__inline'.</font>
00174 <font class="comment"> * we define G_CAN_INLINE, if the compiler seems to be actually</font>
00175 <font class="comment"> * *capable* to do function inlining, in which case inline function bodys</font>
00176 <font class="comment"> * do make sense. we also define G_INLINE_FUNC to properly export the</font>
00177 <font class="comment"> * function prototypes if no inlining can be performed.</font>
00178 <font class="comment"> * we special case most of the stuff, so inline functions can have a normal</font>
00179 <font class="comment"> * implementation by defining G_INLINE_FUNC to extern and G_CAN_INLINE to 1.</font>
00180 <font class="comment"> */</font>
00181 <font class="preprocessor">#ifndef G_INLINE_FUNC</font>
00182 <font class="preprocessor"></font><font class="preprocessor">#  define G_CAN_INLINE 1</font>
00183 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00184 <font class="preprocessor"></font><font class="preprocessor">#ifdef G_HAVE_INLINE</font>
00185 <font class="preprocessor"></font><font class="preprocessor">#  if defined (__GNUC__) &amp;&amp; defined (__STRICT_ANSI__)</font>
00186 <font class="preprocessor"></font><font class="preprocessor">#    undef inline</font>
00187 <font class="preprocessor"></font><font class="preprocessor">#    define inline __inline__</font>
00188 <font class="preprocessor"></font><font class="preprocessor">#  endif</font>
00189 <font class="preprocessor"></font><font class="preprocessor">#else </font><font class="comment">/* !G_HAVE_INLINE */</font>
00190 <font class="preprocessor">#  undef inline</font>
00191 <font class="preprocessor"></font><font class="preprocessor">#  if defined (G_HAVE___INLINE__)</font>
00192 <font class="preprocessor"></font><font class="preprocessor">#    define inline __inline__</font>
00193 <font class="preprocessor"></font><font class="preprocessor">#  else </font><font class="comment">/* !inline &amp;&amp; !__inline__ */</font>
00194 <font class="preprocessor">#    if defined (G_HAVE___INLINE)</font>
00195 <font class="preprocessor"></font><font class="preprocessor">#      define inline __inline</font>
00196 <font class="preprocessor"></font><font class="preprocessor">#    else </font><font class="comment">/* !inline &amp;&amp; !__inline__ &amp;&amp; !__inline */</font>
00197 <font class="preprocessor">#      define inline </font><font class="comment">/* don't inline, then */</font>
00198 <font class="preprocessor">#      ifndef G_INLINE_FUNC</font>
00199 <font class="preprocessor"></font><font class="preprocessor">#    undef G_CAN_INLINE</font>
00200 <font class="preprocessor"></font><font class="preprocessor">#      endif</font>
00201 <font class="preprocessor"></font><font class="preprocessor">#    endif</font>
00202 <font class="preprocessor"></font><font class="preprocessor">#  endif</font>
00203 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00204 <font class="preprocessor"></font><font class="preprocessor">#ifndef G_INLINE_FUNC</font>
00205 <font class="preprocessor"></font><font class="preprocessor">#  ifdef __GNUC__</font>
00206 <font class="preprocessor"></font><font class="preprocessor">#    ifdef __OPTIMIZE__</font>
00207 <font class="preprocessor"></font><font class="preprocessor">#      define G_INLINE_FUNC extern inline</font>
00208 <font class="preprocessor"></font><font class="preprocessor">#    else</font>
00209 <font class="preprocessor"></font><font class="preprocessor">#      undef G_CAN_INLINE</font>
00210 <font class="preprocessor"></font><font class="preprocessor">#      define G_INLINE_FUNC extern</font>
00211 <font class="preprocessor"></font><font class="preprocessor">#    endif</font>
00212 <font class="preprocessor"></font><font class="preprocessor">#  else </font><font class="comment">/* !__GNUC__ */</font>
00213 <font class="preprocessor">#    ifdef G_CAN_INLINE</font>
00214 <font class="preprocessor"></font><font class="preprocessor">#      define G_INLINE_FUNC static inline</font>
00215 <font class="preprocessor"></font><font class="preprocessor">#    else</font>
00216 <font class="preprocessor"></font><font class="preprocessor">#      define G_INLINE_FUNC extern</font>
00217 <font class="preprocessor"></font><font class="preprocessor">#    endif</font>
00218 <font class="preprocessor"></font><font class="preprocessor">#  endif </font><font class="comment">/* !__GNUC__ */</font>
00219 <font class="preprocessor">#endif </font><font class="comment">/* !G_INLINE_FUNC */</font>
00220 
00221 
00222 <font class="comment">/* Provide simple macro statement wrappers (adapted from Perl):</font>
00223 <font class="comment"> *  G_STMT_START { statements; } G_STMT_END;</font>
00224 <font class="comment"> *  can be used as a single statement, as in</font>
00225 <font class="comment"> *  if (x) G_STMT_START { ... } G_STMT_END; else ...</font>
00226 <font class="comment"> *</font>
00227 <font class="comment"> *  For gcc we will wrap the statements within `({' and `})' braces.</font>
00228 <font class="comment"> *  For SunOS they will be wrapped within `if (1)' and `else (void) 0',</font>
00229 <font class="comment"> *  and otherwise within `do' and `while (0)'.</font>
00230 <font class="comment"> */</font>
00231 <font class="preprocessor">#if !(defined (G_STMT_START) &amp;&amp; defined (G_STMT_END))</font>
00232 <font class="preprocessor"></font><font class="preprocessor">#  if defined (__GNUC__) &amp;&amp; !defined (__STRICT_ANSI__) &amp;&amp; !defined (__cplusplus)</font>
00233 <font class="preprocessor"></font><font class="preprocessor">#    define G_STMT_START    (void)(</font>
00234 <font class="preprocessor"></font><font class="preprocessor">#    define G_STMT_END      )</font>
00235 <font class="preprocessor"></font><font class="preprocessor">#  else</font>
00236 <font class="preprocessor"></font><font class="preprocessor">#    if (defined (sun) || defined (__sun__))</font>
00237 <font class="preprocessor"></font><font class="preprocessor">#      define G_STMT_START  if (1)</font>
00238 <font class="preprocessor"></font><font class="preprocessor">#      define G_STMT_END    else (void)0</font>
00239 <font class="preprocessor"></font><font class="preprocessor">#    else</font>
00240 <font class="preprocessor"></font><font class="preprocessor">#      define G_STMT_START  do</font>
00241 <font class="preprocessor"></font><font class="preprocessor">#      define G_STMT_END    while (0)</font>
00242 <font class="preprocessor"></font><font class="preprocessor">#    endif</font>
00243 <font class="preprocessor"></font><font class="preprocessor">#  endif</font>
00244 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00245 <font class="preprocessor"></font>
00246 
00247 <font class="comment">/* Provide macros to feature the GCC function attribute.</font>
00248 <font class="comment"> */</font>
00249 <font class="preprocessor">#if __GNUC__ &gt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt; 4)</font>
00250 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_PRINTF( format_idx, arg_idx )    \</font>
00251 <font class="preprocessor">  __attribute__((format (printf, format_idx, arg_idx)))</font>
00252 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_SCANF( format_idx, arg_idx ) \</font>
00253 <font class="preprocessor">  __attribute__((format (scanf, format_idx, arg_idx)))</font>
00254 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_FORMAT( arg_idx )        \</font>
00255 <font class="preprocessor">  __attribute__((format_arg (arg_idx)))</font>
00256 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_NORETURN             \</font>
00257 <font class="preprocessor">  __attribute__((noreturn))</font>
00258 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_CONST                \</font>
00259 <font class="preprocessor">  __attribute__((const))</font>
00260 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_UNUSED               \</font>
00261 <font class="preprocessor">  __attribute__((unused))</font>
00262 <font class="preprocessor"></font><font class="preprocessor">#else   </font><font class="comment">/* !__GNUC__ */</font>
00263 <font class="preprocessor">#define G_GNUC_PRINTF( format_idx, arg_idx )</font>
00264 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_SCANF( format_idx, arg_idx )</font>
00265 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_FORMAT( arg_idx )</font>
00266 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_NORETURN</font>
00267 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_CONST</font>
00268 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_UNUSED</font>
00269 <font class="preprocessor"></font><font class="preprocessor">#endif  </font><font class="comment">/* !__GNUC__ */</font>
00270 
00271 
00272 <font class="comment">/* Wrap the gcc __PRETTY_FUNCTION__ and __FUNCTION__ variables with</font>
00273 <font class="comment"> * macros, so we can refer to them as strings unconditionally.</font>
00274 <font class="comment"> */</font>
00275 <font class="preprocessor">#ifdef  __GNUC__</font>
00276 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_FUNCTION     __FUNCTION__</font>
00277 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_PRETTY_FUNCTION  __PRETTY_FUNCTION__</font>
00278 <font class="preprocessor"></font><font class="preprocessor">#else   </font><font class="comment">/* !__GNUC__ */</font>
00279 <font class="preprocessor">#define G_GNUC_FUNCTION     ""</font>
00280 <font class="preprocessor"></font><font class="preprocessor">#define G_GNUC_PRETTY_FUNCTION  ""</font>
00281 <font class="preprocessor"></font><font class="preprocessor">#endif  </font><font class="comment">/* !__GNUC__ */</font>
00282 
00283 <font class="comment">/* we try to provide a usefull equivalent for ATEXIT if it is</font>
00284 <font class="comment"> * not defined, but use is actually abandoned. people should</font>
00285 <font class="comment"> * use g_atexit() instead.</font>
00286 <font class="comment"> */</font>
00287 <font class="preprocessor">#ifndef ATEXIT</font>
00288 <font class="preprocessor"></font><font class="preprocessor"># define ATEXIT(proc)   g_ATEXIT(proc)</font>
00289 <font class="preprocessor"></font><font class="preprocessor">#else</font>
00290 <font class="preprocessor"></font><font class="preprocessor"># define G_NATIVE_ATEXIT</font>
00291 <font class="preprocessor"></font><font class="preprocessor">#endif </font><font class="comment">/* ATEXIT */</font>
00292 
00293 <font class="comment">/* Hacker macro to place breakpoints for elected machines.</font>
00294 <font class="comment"> * Actual use is strongly deprecated of course ;)</font>
00295 <font class="comment"> */</font>
00296 <font class="preprocessor">#if defined (__i386__) &amp;&amp; defined (__GNUC__) &amp;&amp; __GNUC__ &gt;= 2</font>
00297 <font class="preprocessor"></font><font class="preprocessor">#define G_BREAKPOINT()      G_STMT_START{ __asm__ __volatile__ ("int $03"); }G_STMT_END</font>
00298 <font class="preprocessor"></font><font class="preprocessor">#elif defined (__alpha__) &amp;&amp; defined (__GNUC__) &amp;&amp; __GNUC__ &gt;= 2</font>
00299 <font class="preprocessor"></font><font class="preprocessor">#define G_BREAKPOINT()      G_STMT_START{ __asm__ __volatile__ ("bpt"); }G_STMT_END</font>
00300 <font class="preprocessor"></font><font class="preprocessor">#else   </font><font class="comment">/* !__i386__ &amp;&amp; !__alpha__ */</font>
00301 <font class="preprocessor">#define G_BREAKPOINT()</font>
00302 <font class="preprocessor"></font><font class="preprocessor">#endif  </font><font class="comment">/* __i386__ */</font>
00303 
00304 
00305 <font class="comment">/* Provide macros for easily allocating memory. The macros</font>
00306 <font class="comment"> *  will cast the allocated memory to the specified type</font>
00307 <font class="comment"> *  in order to avoid compiler warnings. (Makes the code neater).</font>
00308 <font class="comment"> */</font>
00309 
00310 <font class="preprocessor">#ifdef __DMALLOC_H__</font>
00311 <font class="preprocessor"></font><font class="preprocessor">#  define g_new(type, count)        (ALLOC (type, count))</font>
00312 <font class="preprocessor"></font><font class="preprocessor">#  define g_new0(type, count)       (CALLOC (type, count))</font>
00313 <font class="preprocessor"></font><font class="preprocessor">#  define g_renew(type, mem, count) (REALLOC (mem, type, count))</font>
00314 <font class="preprocessor"></font><font class="preprocessor">#else </font><font class="comment">/* __DMALLOC_H__ */</font>
00315 <font class="preprocessor">#  define g_new(type, count)      \</font>
00316 <font class="preprocessor">      ((type *) g_malloc ((unsigned) sizeof (type) * (count)))</font>
00317 <font class="preprocessor"></font><font class="preprocessor">#  define g_new0(type, count)     \</font>
00318 <font class="preprocessor">      ((type *) g_malloc0 ((unsigned) sizeof (type) * (count)))</font>
00319 <font class="preprocessor"></font><font class="preprocessor">#  define g_renew(type, mem, count)   \</font>
00320 <font class="preprocessor">      ((type *) g_realloc (mem, (unsigned) sizeof (type) * (count)))</font>
00321 <font class="preprocessor"></font><font class="preprocessor">#endif </font><font class="comment">/* __DMALLOC_H__ */</font>
00322 
00323 <font class="preprocessor">#define g_mem_chunk_create(type, pre_alloc, alloc_type) ( \</font>
00324 <font class="preprocessor">  g_mem_chunk_new (#type " mem chunks (" #pre_alloc ")", \</font>
00325 <font class="preprocessor">           sizeof (type), \</font>
00326 <font class="preprocessor">           sizeof (type) * (pre_alloc), \</font>
00327 <font class="preprocessor">           (alloc_type)) \</font>
00328 <font class="preprocessor">)</font>
00329 <font class="preprocessor"></font><font class="preprocessor">#define g_chunk_new(type, chunk)    ( \</font>
00330 <font class="preprocessor">  (type *) g_mem_chunk_alloc (chunk) \</font>
00331 <font class="preprocessor">)</font>
00332 <font class="preprocessor"></font><font class="preprocessor">#define g_chunk_new0(type, chunk)   ( \</font>
00333 <font class="preprocessor">  (type *) g_mem_chunk_alloc0 (chunk) \</font>
00334 <font class="preprocessor">)</font>
00335 <font class="preprocessor"></font><font class="preprocessor">#define g_chunk_free(mem, mem_chunk)    G_STMT_START { \</font>
00336 <font class="preprocessor">  g_mem_chunk_free ((mem_chunk), (mem)); \</font>
00337 <font class="preprocessor">} G_STMT_END</font>
00338 <font class="preprocessor"></font>
00339 
00340 <font class="preprocessor">#define g_string(x) #x</font>
00341 <font class="preprocessor"></font>
00342 
00343 <font class="comment">/* Provide macros for error handling. The "assert" macros will</font>
00344 <font class="comment"> *  exit on failure. The "return" macros will exit the current</font>
00345 <font class="comment"> *  function. Two different definitions are given for the macros</font>
00346 <font class="comment"> *  if G_DISABLE_ASSERT is not defined, in order to support gcc's</font>
00347 <font class="comment"> *  __PRETTY_FUNCTION__ capability.</font>
00348 <font class="comment"> */</font>
00349 
00350 <font class="preprocessor">#ifdef G_DISABLE_ASSERT</font>
00351 <font class="preprocessor"></font>
00352 <font class="preprocessor">#define g_assert(expr)</font>
00353 <font class="preprocessor"></font><font class="preprocessor">#define g_assert_not_reached()</font>
00354 <font class="preprocessor"></font>
00355 <font class="preprocessor">#else </font><font class="comment">/* !G_DISABLE_ASSERT */</font>
00356 
00357 <font class="preprocessor">#ifdef __GNUC__</font>
00358 <font class="preprocessor"></font>
00359 <font class="preprocessor">#define g_assert(expr)          G_STMT_START{       \</font>
00360 <font class="preprocessor">     if (!(expr))                       \</font>
00361 <font class="preprocessor">       g_log (G_LOG_DOMAIN,                 \</font>
00362 <font class="preprocessor">          G_LOG_LEVEL_ERROR,                \</font>
00363 <font class="preprocessor">          "file %s: line %d (%s): assertion failed: (%s)",  \</font>
00364 <font class="preprocessor">          __FILE__,                     \</font>
00365 <font class="preprocessor">          __LINE__,                     \</font>
00366 <font class="preprocessor">          __PRETTY_FUNCTION__,              \</font>
00367 <font class="preprocessor">          #expr);           }G_STMT_END</font>
00368 <font class="preprocessor"></font>
00369 <font class="preprocessor">#define g_assert_not_reached()      G_STMT_START{       \</font>
00370 <font class="preprocessor">     g_log (G_LOG_DOMAIN,                   \</font>
00371 <font class="preprocessor">        G_LOG_LEVEL_ERROR,                  \</font>
00372 <font class="preprocessor">        "file %s: line %d (%s): should not be reached", \</font>
00373 <font class="preprocessor">        __FILE__,                       \</font>
00374 <font class="preprocessor">        __LINE__,                       \</font>
00375 <font class="preprocessor">        __PRETTY_FUNCTION__);   }G_STMT_END</font>
00376 <font class="preprocessor"></font>
00377 <font class="preprocessor">#else </font><font class="comment">/* !__GNUC__ */</font>
00378 
00379 <font class="preprocessor">#define g_assert(expr)          G_STMT_START{       \</font>
00380 <font class="preprocessor">     if (!(expr))                       \</font>
00381 <font class="preprocessor">       g_log (G_LOG_DOMAIN,                 \</font>
00382 <font class="preprocessor">          G_LOG_LEVEL_ERROR,                \</font>
00383 <font class="preprocessor">          "file %s: line %d: assertion failed: (%s)",   \</font>
00384 <font class="preprocessor">          __FILE__,                     \</font>
00385 <font class="preprocessor">          __LINE__,                     \</font>
00386 <font class="preprocessor">          #expr);           }G_STMT_END</font>
00387 <font class="preprocessor"></font>
00388 <font class="preprocessor">#define g_assert_not_reached()      G_STMT_START{   \</font>
00389 <font class="preprocessor">     g_log (G_LOG_DOMAIN,               \</font>
00390 <font class="preprocessor">        G_LOG_LEVEL_ERROR,              \</font>
00391 <font class="preprocessor">        "file %s: line %d: should not be reached",  \</font>
00392 <font class="preprocessor">        __FILE__,                   \</font>
00393 <font class="preprocessor">        __LINE__);      }G_STMT_END</font>
00394 <font class="preprocessor"></font>
00395 <font class="preprocessor">#endif </font><font class="comment">/* __GNUC__ */</font>
00396 
00397 <font class="preprocessor">#endif </font><font class="comment">/* !G_DISABLE_ASSERT */</font>
00398 
00399 
00400 <font class="preprocessor">#ifdef G_DISABLE_CHECKS</font>
00401 <font class="preprocessor"></font>
00402 <font class="preprocessor">#define g_return_if_fail(expr)</font>
00403 <font class="preprocessor"></font><font class="preprocessor">#define g_return_val_if_fail(expr,val)</font>
00404 <font class="preprocessor"></font>
00405 <font class="preprocessor">#else </font><font class="comment">/* !G_DISABLE_CHECKS */</font>
00406 
00407 <font class="preprocessor">#ifdef __GNUC__</font>
00408 <font class="preprocessor"></font>
00409 <font class="preprocessor">#define g_return_if_fail(expr)      G_STMT_START{           \</font>
00410 <font class="preprocessor">     if (!(expr))                           \</font>
00411 <font class="preprocessor">       {                                \</font>
00412 <font class="preprocessor">     g_log (G_LOG_DOMAIN,                       \</font>
00413 <font class="preprocessor">        G_LOG_LEVEL_CRITICAL,                   \</font>
00414 <font class="preprocessor">        "file %s: line %d (%s): assertion `%s' failed.",    \</font>
00415 <font class="preprocessor">        __FILE__,                       \</font>
00416 <font class="preprocessor">        __LINE__,                       \</font>
00417 <font class="preprocessor">        __PRETTY_FUNCTION__,                    \</font>
00418 <font class="preprocessor">        #expr);                         \</font>
00419 <font class="preprocessor">     return;                            \</font>
00420 <font class="preprocessor">       };               }G_STMT_END</font>
00421 <font class="preprocessor"></font>
00422 <font class="preprocessor">#define g_return_val_if_fail(expr,val)  G_STMT_START{           \</font>
00423 <font class="preprocessor">     if (!(expr))                           \</font>
00424 <font class="preprocessor">       {                                \</font>
00425 <font class="preprocessor">     g_log (G_LOG_DOMAIN,                       \</font>
00426 <font class="preprocessor">        G_LOG_LEVEL_CRITICAL,                   \</font>
00427 <font class="preprocessor">        "file %s: line %d (%s): assertion `%s' failed.",    \</font>
00428 <font class="preprocessor">        __FILE__,                       \</font>
00429 <font class="preprocessor">        __LINE__,                       \</font>
00430 <font class="preprocessor">        __PRETTY_FUNCTION__,                    \</font>
00431 <font class="preprocessor">        #expr);                         \</font>
00432 <font class="preprocessor">     return val;                            \</font>
00433 <font class="preprocessor">       };               }G_STMT_END</font>
00434 <font class="preprocessor"></font>
00435 <font class="preprocessor">#else </font><font class="comment">/* !__GNUC__ */</font>
00436 
00437 <font class="preprocessor">#define g_return_if_fail(expr)      G_STMT_START{       \</font>
00438 <font class="preprocessor">     if (!(expr))                       \</font>
00439 <font class="preprocessor">       {                            \</font>
00440 <font class="preprocessor">     g_log (G_LOG_DOMAIN,                   \</font>
00441 <font class="preprocessor">        G_LOG_LEVEL_CRITICAL,               \</font>
00442 <font class="preprocessor">        "file %s: line %d: assertion `%s' failed.", \</font>
00443 <font class="preprocessor">        __FILE__,                   \</font>
00444 <font class="preprocessor">        __LINE__,                   \</font>
00445 <font class="preprocessor">        #expr);                     \</font>
00446 <font class="preprocessor">     return;                        \</font>
00447 <font class="preprocessor">       };               }G_STMT_END</font>
00448 <font class="preprocessor"></font>
00449 <font class="preprocessor">#define g_return_val_if_fail(expr, val) G_STMT_START{       \</font>
00450 <font class="preprocessor">     if (!(expr))                       \</font>
00451 <font class="preprocessor">       {                            \</font>
00452 <font class="preprocessor">     g_log (G_LOG_DOMAIN,                   \</font>
00453 <font class="preprocessor">        G_LOG_LEVEL_CRITICAL,               \</font>
00454 <font class="preprocessor">        "file %s: line %d: assertion `%s' failed.", \</font>
00455 <font class="preprocessor">        __FILE__,                   \</font>
00456 <font class="preprocessor">        __LINE__,                   \</font>
00457 <font class="preprocessor">        #expr);                     \</font>
00458 <font class="preprocessor">     return val;                        \</font>
00459 <font class="preprocessor">       };               }G_STMT_END</font>
00460 <font class="preprocessor"></font>
00461 <font class="preprocessor">#endif </font><font class="comment">/* !__GNUC__ */</font>
00462 
00463 <font class="preprocessor">#endif </font><font class="comment">/* !G_DISABLE_CHECKS */</font>
00464 
00465 
00466 <font class="comment">/* Provide type definitions for commonly used types.</font>
00467 <font class="comment"> *  These are useful because a "gint8" can be adjusted</font>
00468 <font class="comment"> *  to be 1 byte (8 bits) on all platforms. Similarly and</font>
00469 <font class="comment"> *  more importantly, "gint32" can be adjusted to be</font>
00470 <font class="comment"> *  4 bytes (32 bits) on all platforms.</font>
00471 <font class="comment"> */</font>
00472 
00473 <font class="keyword">typedef</font> <font class="keywordtype">char</font>   gchar;
00474 <font class="keyword">typedef</font> <font class="keywordtype">short</font>  gshort;
00475 <font class="keyword">typedef</font> <font class="keywordtype">long</font>   glong;
00476 <font class="keyword">typedef</font> <font class="keywordtype">int</font>    gint;
00477 <font class="keyword">typedef</font> gint   gboolean;
00478 
00479 <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>   guchar;
00480 <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">short</font>  gushort;
00481 <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font>   gulong;
00482 <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>    guint;
00483 
00484 <font class="keyword">typedef</font> <font class="keywordtype">float</font>   gfloat;
00485 <font class="keyword">typedef</font> <font class="keywordtype">double</font>  gdouble;
00486 
00487 <font class="comment">/* HAVE_LONG_DOUBLE doesn't work correctly on all platforms.</font>
00488 <font class="comment"> * Since gldouble isn't used anywhere, just disable it for now */</font>
00489 
00490 <font class="preprocessor">#if 0</font>
00491 <font class="preprocessor"></font><font class="preprocessor">#ifdef HAVE_LONG_DOUBLE</font>
00492 <font class="preprocessor"></font><font class="keyword">typedef</font> <font class="keywordtype">long</font> <font class="keywordtype">double</font> gldouble;
00493 <font class="preprocessor">#else </font><font class="comment">/* HAVE_LONG_DOUBLE */</font>
00494 <font class="keyword">typedef</font> <font class="keywordtype">double</font> gldouble;
00495 <font class="preprocessor">#endif </font><font class="comment">/* HAVE_LONG_DOUBLE */</font>
00496 <font class="preprocessor">#endif </font><font class="comment">/* 0 */</font>
00497 
00498 <font class="keyword">typedef</font> <font class="keywordtype">void</font>* gpointer;
00499 <font class="keyword">typedef</font> <font class="keyword">const</font> <font class="keywordtype">void</font> *gconstpointer;
00500 
00501 
00502 <font class="keyword">typedef</font> gint32  gssize;
00503 <font class="keyword">typedef</font> guint32 gsize;
00504 <font class="keyword">typedef</font> guint32 GQuark;
00505 <font class="keyword">typedef</font> gint32  GTime;
00506 
00507 
00508 <font class="comment">/* Portable endian checks and conversions</font>
00509 <font class="comment"> *</font>
00510 <font class="comment"> * glibconfig.h defines G_BYTE_ORDER which expands to one of</font>
00511 <font class="comment"> * the below macros.</font>
00512 <font class="comment"> */</font>
00513 <font class="preprocessor">#define G_LITTLE_ENDIAN 1234</font>
00514 <font class="preprocessor"></font><font class="preprocessor">#define G_BIG_ENDIAN    4321</font>
00515 <font class="preprocessor"></font><font class="preprocessor">#define G_PDP_ENDIAN    3412        </font><font class="comment">/* unused, need specific PDP check */</font>   
00516 
00517 
00518 <font class="comment">/* Basic bit swapping functions</font>
00519 <font class="comment"> */</font>
00520 <font class="preprocessor">#define GUINT16_SWAP_LE_BE_CONSTANT(val)    ((guint16) ( \</font>
00521 <font class="preprocessor">    (((guint16) (val) &amp; (guint16) 0x00ffU) &lt;&lt; 8) | \</font>
00522 <font class="preprocessor">    (((guint16) (val) &amp; (guint16) 0xff00U) &gt;&gt; 8)))</font>
00523 <font class="preprocessor"></font><font class="preprocessor">#define GUINT32_SWAP_LE_BE_CONSTANT(val)    ((guint32) ( \</font>
00524 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0x000000ffU) &lt;&lt; 24) | \</font>
00525 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0x0000ff00U) &lt;&lt;  8) | \</font>
00526 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0x00ff0000U) &gt;&gt;  8) | \</font>
00527 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0xff000000U) &gt;&gt; 24)))</font>
00528 <font class="preprocessor"></font>
00529 <font class="comment">/* Intel specific stuff for speed</font>
00530 <font class="comment"> */</font>
00531 <font class="preprocessor">#if defined (__i386__) &amp;&amp; defined (__GNUC__) &amp;&amp; __GNUC__ &gt;= 2</font>
00532 <font class="preprocessor"></font><font class="preprocessor">#  define GUINT16_SWAP_LE_BE_X86(val) \</font>
00533 <font class="preprocessor">     (__extension__                 \</font>
00534 <font class="preprocessor">      ({ register guint16 __v;              \</font>
00535 <font class="preprocessor">     if (__builtin_constant_p (val))        \</font>
00536 <font class="preprocessor">       __v = GUINT16_SWAP_LE_BE_CONSTANT (val); \</font>
00537 <font class="preprocessor">     else                       \</font>
00538 <font class="preprocessor">       __asm__ __const__ ("rorw $8, %w0"        \</font>
00539 <font class="preprocessor">                  : "=r" (__v)      \</font>
00540 <font class="preprocessor">                  : "0" ((guint16) (val))); \</font>
00541 <font class="preprocessor">    __v; }))</font>
00542 <font class="preprocessor"></font><font class="preprocessor">#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_X86 (val))</font>
00543 <font class="preprocessor"></font><font class="preprocessor">#  if !defined(__i486__) &amp;&amp; !defined(__i586__) \</font>
00544 <font class="preprocessor">      &amp;&amp; !defined(__pentium__) &amp;&amp; !defined(__i686__) &amp;&amp; !defined(__pentiumpro__)</font>
00545 <font class="preprocessor"></font><font class="preprocessor">#     define GUINT32_SWAP_LE_BE_X86(val) \</font>
00546 <font class="preprocessor">        (__extension__                      \</font>
00547 <font class="preprocessor">         ({ register guint32 __v;               \</font>
00548 <font class="preprocessor">        if (__builtin_constant_p (val))         \</font>
00549 <font class="preprocessor">          __v = GUINT32_SWAP_LE_BE_CONSTANT (val);      \</font>
00550 <font class="preprocessor">      else                          \</font>
00551 <font class="preprocessor">        __asm__ __const__ ("rorw $8, %w0\n\t"       \</font>
00552 <font class="preprocessor">                   "rorl $16, %0\n\t"       \</font>
00553 <font class="preprocessor">                   "rorw $8, %w0"           \</font>
00554 <font class="preprocessor">                   : "=r" (__v)         \</font>
00555 <font class="preprocessor">                   : "0" ((guint32) (val)));    \</font>
00556 <font class="preprocessor">    __v; }))</font>
00557 <font class="preprocessor"></font><font class="preprocessor">#  else </font><font class="comment">/* 486 and higher has bswap */</font>
00558 <font class="preprocessor">#     define GUINT32_SWAP_LE_BE_X86(val) \</font>
00559 <font class="preprocessor">        (__extension__                      \</font>
00560 <font class="preprocessor">         ({ register guint32 __v;               \</font>
00561 <font class="preprocessor">        if (__builtin_constant_p (val))         \</font>
00562 <font class="preprocessor">          __v = GUINT32_SWAP_LE_BE_CONSTANT (val);      \</font>
00563 <font class="preprocessor">      else                          \</font>
00564 <font class="preprocessor">        __asm__ __const__ ("bswap %0"           \</font>
00565 <font class="preprocessor">                   : "=r" (__v)         \</font>
00566 <font class="preprocessor">                   : "0" ((guint32) (val)));    \</font>
00567 <font class="preprocessor">    __v; }))</font>
00568 <font class="preprocessor"></font><font class="preprocessor">#  endif </font><font class="comment">/* processor specific 32-bit stuff */</font>
00569 <font class="preprocessor">#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_X86 (val))</font>
00570 <font class="preprocessor"></font><font class="preprocessor">#else </font><font class="comment">/* !__i386__ */</font>
00571 <font class="preprocessor">#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))</font>
00572 <font class="preprocessor"></font><font class="preprocessor">#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))</font>
00573 <font class="preprocessor"></font><font class="preprocessor">#endif </font><font class="comment">/* __i386__ */</font>
00574 
00575 <font class="preprocessor">#ifdef G_HAVE_GINT64</font>
00576 <font class="preprocessor"></font><font class="preprocessor">#  define GUINT64_SWAP_LE_BE_CONSTANT(val)  ((guint64) ( \</font>
00577 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00578 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x00000000000000ffU)) &lt;&lt; 56) |  \</font>
00579 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00580 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x000000000000ff00U)) &lt;&lt; 40) |  \</font>
00581 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00582 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x0000000000ff0000U)) &lt;&lt; 24) |  \</font>
00583 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00584 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x00000000ff000000U)) &lt;&lt;  8) |  \</font>
00585 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00586 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x000000ff00000000U)) &gt;&gt;  8) |  \</font>
00587 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00588 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x0000ff0000000000U)) &gt;&gt; 24) |  \</font>
00589 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00590 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0x00ff000000000000U)) &gt;&gt; 40) |  \</font>
00591 <font class="preprocessor">      (((guint64) (val) &amp;                       \</font>
00592 <font class="preprocessor">    (guint64) G_GINT64_CONSTANT(0xff00000000000000U)) &gt;&gt; 56)))</font>
00593 <font class="preprocessor"></font><font class="preprocessor">#  if defined (__i386__) &amp;&amp; defined (__GNUC__) &amp;&amp; __GNUC__ &gt;= 2</font>
00594 <font class="preprocessor"></font><font class="preprocessor">#    define GUINT64_SWAP_LE_BE_X86(val) \</font>
00595 <font class="preprocessor">    (__extension__                      \</font>
00596 <font class="preprocessor">     ({ union { guint64 __ll;               \</font>
00597 <font class="preprocessor">            guint32 __l[2]; } __r;          \</font>
00598 <font class="preprocessor">        if (__builtin_constant_p (val))         \</font>
00599 <font class="preprocessor">          __r.__ll = GUINT64_SWAP_LE_BE_CONSTANT (val); \</font>
00600 <font class="preprocessor">        else                        \</font>
00601 <font class="preprocessor">          {                         \</font>
00602 <font class="preprocessor">        union { guint64 __ll;               \</font>
00603 <font class="preprocessor">            guint32 __l[2]; } __w;          \</font>
00604 <font class="preprocessor">        __w.__ll = ((guint64) val);         \</font>
00605 <font class="preprocessor">        __r.__l[0] = GUINT32_SWAP_LE_BE (__w.__l[1]);   \</font>
00606 <font class="preprocessor">        __r.__l[1] = GUINT32_SWAP_LE_BE (__w.__l[0]);   \</font>
00607 <font class="preprocessor">          }                         \</font>
00608 <font class="preprocessor">      __r.__ll; }))</font>
00609 <font class="preprocessor"></font><font class="preprocessor">#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_X86 (val))</font>
00610 <font class="preprocessor"></font><font class="preprocessor">#  else </font><font class="comment">/* !__i386__ */</font>
00611 <font class="preprocessor">#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT(val))</font>
00612 <font class="preprocessor"></font><font class="preprocessor">#  endif</font>
00613 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00614 <font class="preprocessor"></font>
00615 <font class="preprocessor">#define GUINT16_SWAP_LE_PDP(val)    ((guint16) (val))</font>
00616 <font class="preprocessor"></font><font class="preprocessor">#define GUINT16_SWAP_BE_PDP(val)    (GUINT16_SWAP_LE_BE (val))</font>
00617 <font class="preprocessor"></font><font class="preprocessor">#define GUINT32_SWAP_LE_PDP(val)    ((guint32) ( \</font>
00618 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0x0000ffffU) &lt;&lt; 16) | \</font>
00619 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0xffff0000U) &gt;&gt; 16)))</font>
00620 <font class="preprocessor"></font><font class="preprocessor">#define GUINT32_SWAP_BE_PDP(val)    ((guint32) ( \</font>
00621 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0x00ff00ffU) &lt;&lt; 8) | \</font>
00622 <font class="preprocessor">    (((guint32) (val) &amp; (guint32) 0xff00ff00U) &gt;&gt; 8)))</font>
00623 <font class="preprocessor"></font>
00624 <font class="comment">/* The G*_TO_?E() macros are defined in glibconfig.h.</font>
00625 <font class="comment"> * The transformation is symmetric, so the FROM just maps to the TO.</font>
00626 <font class="comment"> */</font>
00627 <font class="preprocessor">#define GINT16_FROM_LE(val) (GINT16_TO_LE (val))</font>
00628 <font class="preprocessor"></font><font class="preprocessor">#define GUINT16_FROM_LE(val)    (GUINT16_TO_LE (val))</font>
00629 <font class="preprocessor"></font><font class="preprocessor">#define GINT16_FROM_BE(val) (GINT16_TO_BE (val))</font>
00630 <font class="preprocessor"></font><font class="preprocessor">#define GUINT16_FROM_BE(val)    (GUINT16_TO_BE (val))</font>
00631 <font class="preprocessor"></font><font class="preprocessor">#define GINT32_FROM_LE(val) (GINT32_TO_LE (val))</font>
00632 <font class="preprocessor"></font><font class="preprocessor">#define GUINT32_FROM_LE(val)    (GUINT32_TO_LE (val))</font>
00633 <font class="preprocessor"></font><font class="preprocessor">#define GINT32_FROM_BE(val) (GINT32_TO_BE (val))</font>
00634 <font class="preprocessor"></font><font class="preprocessor">#define GUINT32_FROM_BE(val)    (GUINT32_TO_BE (val))</font>
00635 <font class="preprocessor"></font>
00636 <font class="preprocessor">#ifdef G_HAVE_GINT64</font>
00637 <font class="preprocessor"></font><font class="preprocessor">#define GINT64_FROM_LE(val) (GINT64_TO_LE (val))</font>
00638 <font class="preprocessor"></font><font class="preprocessor">#define GUINT64_FROM_LE(val)    (GUINT64_TO_LE (val))</font>
00639 <font class="preprocessor"></font><font class="preprocessor">#define GINT64_FROM_BE(val) (GINT64_TO_BE (val))</font>
00640 <font class="preprocessor"></font><font class="preprocessor">#define GUINT64_FROM_BE(val)    (GUINT64_TO_BE (val))</font>
00641 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00642 <font class="preprocessor"></font>
00643 <font class="preprocessor">#define GLONG_FROM_LE(val)  (GLONG_TO_LE (val))</font>
00644 <font class="preprocessor"></font><font class="preprocessor">#define GULONG_FROM_LE(val) (GULONG_TO_LE (val))</font>
00645 <font class="preprocessor"></font><font class="preprocessor">#define GLONG_FROM_BE(val)  (GLONG_TO_BE (val))</font>
00646 <font class="preprocessor"></font><font class="preprocessor">#define GULONG_FROM_BE(val) (GULONG_TO_BE (val))</font>
00647 <font class="preprocessor"></font>
00648 <font class="preprocessor">#define GINT_FROM_LE(val)   (GINT_TO_LE (val))</font>
00649 <font class="preprocessor"></font><font class="preprocessor">#define GUINT_FROM_LE(val)  (GUINT_TO_LE (val))</font>
00650 <font class="preprocessor"></font><font class="preprocessor">#define GINT_FROM_BE(val)   (GINT_TO_BE (val))</font>
00651 <font class="preprocessor"></font><font class="preprocessor">#define GUINT_FROM_BE(val)  (GUINT_TO_BE (val))</font>
00652 <font class="preprocessor"></font>
00653 
00654 <font class="comment">/* Portable versions of host-network order stuff</font>
00655 <font class="comment"> */</font>
00656 <font class="preprocessor">#define g_ntohl(val) (GUINT32_FROM_BE (val))</font>
00657 <font class="preprocessor"></font><font class="preprocessor">#define g_ntohs(val) (GUINT16_FROM_BE (val))</font>
00658 <font class="preprocessor"></font><font class="preprocessor">#define g_htonl(val) (GUINT32_TO_BE (val))</font>
00659 <font class="preprocessor"></font><font class="preprocessor">#define g_htons(val) (GUINT16_TO_BE (val))</font>
00660 <font class="preprocessor"></font>
00661 
00662 <font class="comment">/* Glib version.</font>
00663 <font class="comment"> * we prefix variable declarations so they can</font>
00664 <font class="comment"> * properly get exported in windows dlls.</font>
00665 <font class="comment"> */</font>
00666 <font class="preprocessor">#ifdef NATIVE_WIN32</font>
00667 <font class="preprocessor"></font><font class="preprocessor">#  ifdef GLIB_COMPILATION</font>
00668 <font class="preprocessor"></font><font class="preprocessor">#    define GUTILS_C_VAR __declspec(dllexport)</font>
00669 <font class="preprocessor"></font><font class="preprocessor">#  else </font><font class="comment">/* !GLIB_COMPILATION */</font>
00670 <font class="preprocessor">#    define GUTILS_C_VAR extern __declspec(dllimport)</font>
00671 <font class="preprocessor"></font><font class="preprocessor">#  endif </font><font class="comment">/* !GLIB_COMPILATION */</font>
00672 <font class="preprocessor">#else </font><font class="comment">/* !NATIVE_WIN32 */</font>
00673 <font class="preprocessor">#  define GUTILS_C_VAR extern</font>
00674 <font class="preprocessor"></font><font class="preprocessor">#endif </font><font class="comment">/* !NATIVE_WIN32 */</font>
00675 
00676 GUTILS_C_VAR <font class="keyword">const</font> guint glib_major_version;
00677 GUTILS_C_VAR <font class="keyword">const</font> guint glib_minor_version;
00678 GUTILS_C_VAR <font class="keyword">const</font> guint glib_micro_version;
00679 GUTILS_C_VAR <font class="keyword">const</font> guint glib_interface_age;
00680 GUTILS_C_VAR <font class="keyword">const</font> guint glib_binary_age;
00681 
00682 <font class="preprocessor">#define GLIB_CHECK_VERSION(major,minor,micro)    \</font>
00683 <font class="preprocessor">    (GLIB_MAJOR_VERSION &gt; (major) || \</font>
00684 <font class="preprocessor">     (GLIB_MAJOR_VERSION == (major) &amp;&amp; GLIB_MINOR_VERSION &gt; (minor)) || \</font>
00685 <font class="preprocessor">     (GLIB_MAJOR_VERSION == (major) &amp;&amp; GLIB_MINOR_VERSION == (minor) &amp;&amp; \</font>
00686 <font class="preprocessor">      GLIB_MICRO_VERSION &gt;= (micro)))</font>
00687 <font class="preprocessor"></font>
00688 <font class="comment">/* Forward declarations of glib types.</font>
00689 <font class="comment"> */</font>
00690 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GAllocator  GAllocator;
00691 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GArray      GArray;
00692 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GByteArray  GByteArray;
00693 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GCache      GCache;
00694 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GCompletion GCompletion;
00695 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GData       GData;
00696 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GDebugKey   GDebugKey;
00697 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GHashTable  GHashTable;
00698 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GHook       GHook;
00699 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GHookList   GHookList;
00700 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GList       GList;
00701 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GMemChunk   GMemChunk;
00702 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GNode       GNode;
00703 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GPtrArray   GPtrArray;
00704 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GRelation   GRelation;
00705 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GScanner    GScanner;
00706 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GScannerConfig  GScannerConfig;
00707 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GSList      GSList;
00708 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GString     GString;
00709 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GStringChunk    GStringChunk;
00710 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GTimer      GTimer;
00711 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GTree       GTree;
00712 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GTuples     GTuples;
00713 <font class="keyword">typedef</font> <font class="keyword">union  </font>_GTokenValue GTokenValue;
00714 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GIOChannel  GIOChannel;
00715 
00716 <font class="comment">/* Tree traverse flags */</font>
00717 <font class="keyword">typedef</font> <font class="keyword">enum</font>
00718 {
00719   G_TRAVERSE_LEAFS  = 1 &lt;&lt; 0,
00720   G_TRAVERSE_NON_LEAFS  = 1 &lt;&lt; 1,
00721   G_TRAVERSE_ALL    = G_TRAVERSE_LEAFS | G_TRAVERSE_NON_LEAFS,
00722   G_TRAVERSE_MASK   = 0x03
00723 } GTraverseFlags;
00724 
00725 <font class="comment">/* Tree traverse orders */</font>
00726 <font class="keyword">typedef</font> <font class="keyword">enum</font>
00727 {
00728   G_IN_ORDER,
00729   G_PRE_ORDER,
00730   G_POST_ORDER,
00731   G_LEVEL_ORDER
00732 } GTraverseType;
00733 
00734 <font class="comment">/* Log level shift offset for user defined</font>
00735 <font class="comment"> * log levels (0-7 are used by GLib).</font>
00736 <font class="comment"> */</font>
00737 <font class="preprocessor">#define G_LOG_LEVEL_USER_SHIFT  (8)</font>
00738 <font class="preprocessor"></font>
00739 <font class="comment">/* Glib log levels and flags.</font>
00740 <font class="comment"> */</font>
00741 <font class="keyword">typedef</font> <font class="keyword">enum</font>
00742 {
00743   <font class="comment">/* log flags */</font>
00744   G_LOG_FLAG_RECURSION      = 1 &lt;&lt; 0,
00745   G_LOG_FLAG_FATAL      = 1 &lt;&lt; 1,
00746   
00747   <font class="comment">/* GLib log levels */</font>
00748   G_LOG_LEVEL_ERROR     = 1 &lt;&lt; 2,   <font class="comment">/* always fatal */</font>
00749   G_LOG_LEVEL_CRITICAL      = 1 &lt;&lt; 3,
00750   G_LOG_LEVEL_WARNING       = 1 &lt;&lt; 4,
00751   G_LOG_LEVEL_MESSAGE       = 1 &lt;&lt; 5,
00752   G_LOG_LEVEL_INFO      = 1 &lt;&lt; 6,
00753   G_LOG_LEVEL_DEBUG     = 1 &lt;&lt; 7,
00754   
00755   G_LOG_LEVEL_MASK      = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
00756 } GLogLevelFlags;
00757 
00758 <font class="comment">/* GLib log levels that are considered fatal by default */</font>
00759 <font class="preprocessor">#define G_LOG_FATAL_MASK    (G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR)</font>
00760 <font class="preprocessor"></font>
00761 
00762 <font class="keyword">typedef</font> gpointer    (*GCacheNewFunc)    (gpointer   key);
00763 <font class="keyword">typedef</font> gpointer    (*GCacheDupFunc)    (gpointer   value);
00764 <font class="keyword">typedef</font> void        (*GCacheDestroyFunc)    (gpointer   value);
00765 <font class="keyword">typedef</font> gint        (*GCompareFunc)     (gconstpointer  a,
00766                          gconstpointer  b);
00767 <font class="keyword">typedef</font> gchar*      (*GCompletionFunc)  (gpointer);
00768 <font class="keyword">typedef</font> void        (*GDestroyNotify)   (gpointer   data);
00769 <font class="keyword">typedef</font> void        (*GDataForeachFunc) (GQuark     key_id,
00770                          gpointer   data,
00771                          gpointer   user_data);
00772 <font class="keyword">typedef</font> void        (*GFunc)        (gpointer   data,
00773                          gpointer   user_data);
00774 <font class="keyword">typedef</font> guint       (*GHashFunc)        (gconstpointer  key);
00775 <font class="keyword">typedef</font> void        (*GFreeFunc)        (gpointer   data);
00776 <font class="keyword">typedef</font> void        (*GHFunc)       (gpointer   key,
00777                          gpointer   value,
00778                          gpointer   user_data);
00779 <font class="keyword">typedef</font> gboolean    (*GHRFunc)      (gpointer   key,
00780                          gpointer   value,
00781                          gpointer   user_data);
00782 <font class="keyword">typedef</font> gint        (*GHookCompareFunc) (GHook      *new_hook,
00783                          GHook      *sibling);
00784 <font class="keyword">typedef</font> gboolean    (*GHookFindFunc)    (GHook      *hook,
00785                          gpointer    data);
00786 <font class="keyword">typedef</font> void        (*GHookMarshaller)  (GHook      *hook,
00787                          gpointer    data);
00788 <font class="keyword">typedef</font> gboolean    (*GHookCheckMarshaller) (GHook      *hook,
00789                          gpointer    data);
00790 <font class="keyword">typedef</font> void        (*GHookFunc)        (gpointer    data);
00791 <font class="keyword">typedef</font> gboolean    (*GHookCheckFunc)   (gpointer    data);
00792 <font class="keyword">typedef</font> void        (*GHookFreeFunc)    (GHookList      *hook_list,
00793                          GHook          *hook);
00794 <font class="keyword">typedef</font> void        (*GLogFunc)     (<font class="keyword">const</font> gchar   *log_domain,
00795                          GLogLevelFlags log_level,
00796                          <font class="keyword">const</font> gchar   *message,
00797                          gpointer   user_data);
00798 <font class="keyword">typedef</font> gboolean    (*GNodeTraverseFunc)    (GNode         *node,
00799                          gpointer   data);
00800 <font class="keyword">typedef</font> void        (*GNodeForeachFunc) (GNode         *node,
00801                          gpointer   data);
00802 <font class="keyword">typedef</font> gint        (*GSearchFunc)      (gpointer   key,
00803                          gpointer   data);
00804 <font class="keyword">typedef</font> void        (*GScannerMsgFunc)  (GScanner      *scanner,
00805                          gchar         *message,
00806                          gint       error);
00807 <font class="keyword">typedef</font> gint        (*GTraverseFunc)    (gpointer   key,
00808                          gpointer   value,
00809                          gpointer   data);
00810 <font class="keyword">typedef</font> void        (*GVoidFunc)        (<font class="keywordtype">void</font>);
00811 
00812 
00813 <font class="keyword">struct </font>_GList
00814 {
00815   gpointer data;
00816   GList *next;
00817   GList *prev;
00818 };
00819 
00820 <font class="keyword">struct </font>_GSList
00821 {
00822   gpointer data;
00823   GSList *next;
00824 };
00825 
00826 <font class="keyword">struct </font>_GString
00827 {
00828   gchar *str;
00829   gint len;
00830 };
00831 
00832 <font class="keyword">struct </font>_GArray
00833 {
00834   gchar *data;
00835   guint len;
00836 };
00837 
00838 <font class="keyword">struct </font>_GByteArray
00839 {
00840   guint8 *data;
00841   guint   len;
00842 };
00843 
00844 <font class="keyword">struct </font>_GPtrArray
00845 {
00846   gpointer *pdata;
00847   guint     len;
00848 };
00849 
00850 <font class="keyword">struct </font>_GTuples
00851 {
00852   guint len;
00853 };
00854 
00855 <font class="keyword">struct </font>_GDebugKey
00856 {
00857   gchar *key;
00858   guint  value;
00859 };
00860 
00861 
00862 <font class="comment">/* Doubly linked lists</font>
00863 <font class="comment"> */</font>
00864 <font class="keywordtype">void</font>   g_list_push_allocator    (GAllocator     *allocator);
00865 <font class="keywordtype">void</font>   g_list_pop_allocator     (<font class="keywordtype">void</font>);
00866 GList* g_list_alloc     (<font class="keywordtype">void</font>);
00867 <font class="keywordtype">void</font>   g_list_free      (GList      *list);
00868 <font class="keywordtype">void</font>   g_list_free_1        (GList      *list);
00869 GList* g_list_append        (GList      *list,
00870                  gpointer    data);
00871 GList* g_list_prepend       (GList      *list,
00872                  gpointer    data);
00873 GList* g_list_insert        (GList      *list,
00874                  gpointer    data,
00875                  gint        position);
00876 GList* g_list_insert_sorted (GList      *list,
00877                  gpointer    data,
00878                  GCompareFunc    func);
00879 GList* g_list_concat        (GList      *list1,
00880                  GList      *list2);
00881 GList* g_list_remove        (GList      *list,
00882                  gpointer    data);
00883 GList* g_list_remove_link   (GList      *list,
00884                  GList      *llink);
00885 GList* g_list_reverse       (GList      *list);
00886 GList* g_list_copy      (GList      *list);
00887 GList* g_list_nth       (GList      *list,
00888                  guint       n);
00889 GList* g_list_find      (GList      *list,
00890                  gpointer    data);
00891 GList* g_list_find_custom   (GList      *list,
00892                  gpointer    data,
00893                  GCompareFunc    func);
00894 gint   g_list_position      (GList      *list,
00895                  GList      *llink);
00896 gint   g_list_index     (GList      *list,
00897                  gpointer    data);
00898 GList* g_list_last      (GList      *list);
00899 GList* g_list_first     (GList      *list);
00900 guint  g_list_length        (GList      *list);
00901 <font class="keywordtype">void</font>   g_list_foreach       (GList      *list,
00902                  GFunc       func,
00903                  gpointer    user_data);
00904 GList* g_list_sort              (GList          *list,
00905                          GCompareFunc    compare_func);
00906 gpointer g_list_nth_data    (GList      *list,
00907                  guint       n);
00908 <font class="preprocessor">#define g_list_previous(list)   ((list) ? (((GList *)(list))-&gt;prev) : NULL)</font>
00909 <font class="preprocessor"></font><font class="preprocessor">#define g_list_next(list)   ((list) ? (((GList *)(list))-&gt;next) : NULL)</font>
00910 <font class="preprocessor"></font>
00911 
00912 <font class="comment">/* Singly linked lists</font>
00913 <font class="comment"> */</font>
00914 <font class="keywordtype">void</font>    g_slist_push_allocator  (GAllocator     *allocator);
00915 <font class="keywordtype">void</font>    g_slist_pop_allocator   (<font class="keywordtype">void</font>);
00916 GSList* g_slist_alloc       (<font class="keywordtype">void</font>);
00917 <font class="keywordtype">void</font>    g_slist_free        (GSList     *list);
00918 <font class="keywordtype">void</font>    g_slist_free_1      (GSList     *list);
00919 GSList* g_slist_append      (GSList     *list,
00920                  gpointer    data);
00921 GSList* g_slist_prepend     (GSList     *list,
00922                  gpointer    data);
00923 GSList* g_slist_insert      (GSList     *list,
00924                  gpointer    data,
00925                  gint        position);
00926 GSList* g_slist_insert_sorted   (GSList     *list,
00927                  gpointer    data,
00928                  GCompareFunc    func);
00929 GSList* g_slist_concat      (GSList     *list1,
00930                  GSList     *list2);
00931 GSList* g_slist_remove      (GSList     *list,
00932                  gpointer    data);
00933 GSList* g_slist_remove_link (GSList     *list,
00934                  GSList     *llink);
00935 GSList* g_slist_reverse     (GSList     *list);
00936 GSList* g_slist_copy        (GSList     *list);
00937 GSList* g_slist_nth     (GSList     *list,
00938                  guint       n);
00939 GSList* g_slist_find        (GSList     *list,
00940                  gpointer    data);
00941 GSList* g_slist_find_custom (GSList     *list,
00942                  gpointer    data,
00943                  GCompareFunc    func);
00944 gint    g_slist_position    (GSList     *list,
00945                  GSList     *llink);
00946 gint    g_slist_index       (GSList     *list,
00947                  gpointer    data);
00948 GSList* g_slist_last        (GSList     *list);
00949 guint   g_slist_length      (GSList     *list);
00950 <font class="keywordtype">void</font>    g_slist_foreach     (GSList     *list,
00951                  GFunc       func,
00952                  gpointer    user_data);
00953 GSList*  g_slist_sort           (GSList          *list,
00954                          GCompareFunc    compare_func);
00955 gpointer g_slist_nth_data   (GSList     *list,
00956                  guint       n);
00957 <font class="preprocessor">#define g_slist_next(slist) ((slist) ? (((GSList *)(slist))-&gt;next) : NULL)</font>
00958 <font class="preprocessor"></font>
00959 
00960 <font class="comment">/* Hash tables</font>
00961 <font class="comment"> */</font>
00962 GHashTable* g_hash_table_new        (GHashFunc   hash_func,
00963                      GCompareFunc    key_compare_func);
00964 <font class="keywordtype">void</font>        g_hash_table_destroy    (GHashTable *hash_table);
00965 <font class="keywordtype">void</font>        g_hash_table_insert     (GHashTable *hash_table,
00966                      gpointer    key,
00967                      gpointer    value);
00968 <font class="keywordtype">void</font>        g_hash_table_remove     (GHashTable *hash_table,
00969                      gconstpointer   key);
00970 gpointer    g_hash_table_lookup     (GHashTable *hash_table,
00971                      gconstpointer   key);
00972 gboolean    g_hash_table_lookup_extended(GHashTable *hash_table,
00973                      gconstpointer   lookup_key,
00974                      gpointer   *orig_key,
00975                      gpointer   *value);
00976 <font class="keywordtype">void</font>        g_hash_table_freeze     (GHashTable *hash_table);
00977 <font class="keywordtype">void</font>        g_hash_table_thaw       (GHashTable *hash_table);
00978 <font class="keywordtype">void</font>        g_hash_table_foreach    (GHashTable *hash_table,
00979                      GHFunc      func,
00980                      gpointer    user_data);
00981 guint       g_hash_table_foreach_remove (GHashTable *hash_table,
00982                      GHRFunc     func,
00983                      gpointer    user_data);
00984 guint       g_hash_table_size       (GHashTable *hash_table);
00985 
00986 
00987 <font class="comment">/* Caches</font>
00988 <font class="comment"> */</font>
00989 GCache*  g_cache_new           (GCacheNewFunc      value_new_func,
00990                 GCacheDestroyFunc  value_destroy_func,
00991                 GCacheDupFunc      key_dup_func,
00992                 GCacheDestroyFunc  key_destroy_func,
00993                 GHashFunc      hash_key_func,
00994                 GHashFunc      hash_value_func,
00995                 GCompareFunc       key_compare_func);
00996 <font class="keywordtype">void</font>     g_cache_destroy       (GCache        *cache);
00997 gpointer g_cache_insert        (GCache        *cache,
00998                 gpointer       key);
00999 <font class="keywordtype">void</font>     g_cache_remove        (GCache        *cache,
01000                 gpointer       value);
01001 <font class="keywordtype">void</font>     g_cache_key_foreach   (GCache        *cache,
01002                 GHFunc         func,
01003                 gpointer       user_data);
01004 <font class="keywordtype">void</font>     g_cache_value_foreach (GCache        *cache,
01005                 GHFunc         func,
01006                 gpointer       user_data);
01007 
01008 
01009 <font class="comment">/* Balanced binary trees</font>
01010 <font class="comment"> */</font>
01011 GTree*   g_tree_new  (GCompareFunc   key_compare_func);
01012 <font class="keywordtype">void</font>     g_tree_destroy  (GTree     *tree);
01013 <font class="keywordtype">void</font>     g_tree_insert   (GTree     *tree,
01014               gpointer   key,
01015               gpointer   value);
01016 <font class="keywordtype">void</font>     g_tree_remove   (GTree     *tree,
01017               gpointer   key);
01018 gpointer g_tree_lookup   (GTree     *tree,
01019               gpointer   key);
01020 <font class="keywordtype">void</font>     g_tree_traverse (GTree     *tree,
01021               GTraverseFunc  traverse_func,
01022               GTraverseType  traverse_type,
01023               gpointer   data);
01024 gpointer g_tree_search   (GTree     *tree,
01025               GSearchFunc    search_func,
01026               gpointer   data);
01027 gint     g_tree_height   (GTree     *tree);
01028 gint     g_tree_nnodes   (GTree     *tree);
01029 
01030 
01031 
01032 <font class="comment">/* N-way tree implementation</font>
01033 <font class="comment"> */</font>
01034 <font class="keyword">struct </font>_GNode
01035 {
01036   gpointer data;
01037   GNode   *next;
01038   GNode   *prev;
01039   GNode   *parent;
01040   GNode   *children;
01041 };
01042 
01043 <font class="preprocessor">#define  G_NODE_IS_ROOT(node)   (((GNode*) (node))-&gt;parent == NULL &amp;&amp; \</font>
01044 <font class="preprocessor">                 ((GNode*) (node))-&gt;prev == NULL &amp;&amp; \</font>
01045 <font class="preprocessor">                 ((GNode*) (node))-&gt;next == NULL)</font>
01046 <font class="preprocessor"></font><font class="preprocessor">#define  G_NODE_IS_LEAF(node)   (((GNode*) (node))-&gt;children == NULL)</font>
01047 <font class="preprocessor"></font>
01048 <font class="keywordtype">void</font>     g_node_push_allocator  (GAllocator       *allocator);
01049 <font class="keywordtype">void</font>     g_node_pop_allocator   (<font class="keywordtype">void</font>);
01050 GNode*   g_node_new     (gpointer      data);
01051 <font class="keywordtype">void</font>     g_node_destroy     (GNode        *root);
01052 <font class="keywordtype">void</font>     g_node_unlink      (GNode        *node);
01053 GNode*   g_node_insert      (GNode        *parent,
01054                  gint          position,
01055                  GNode        *node);
01056 GNode*   g_node_insert_before   (GNode        *parent,
01057                  GNode        *sibling,
01058                  GNode        *node);
01059 GNode*   g_node_prepend     (GNode        *parent,
01060                  GNode        *node);
01061 guint    g_node_n_nodes     (GNode        *root,
01062                  GTraverseFlags    flags);
01063 GNode*   g_node_get_root    (GNode        *node);
01064 gboolean g_node_is_ancestor (GNode        *node,
01065                  GNode        *descendant);
01066 guint    g_node_depth       (GNode        *node);
01067 GNode*   g_node_find        (GNode        *root,
01068                  GTraverseType     order,
01069                  GTraverseFlags    flags,
01070                  gpointer      data);
01071 
01072 <font class="comment">/* convenience macros */</font>
01073 <font class="preprocessor">#define g_node_append(parent, node)             \</font>
01074 <font class="preprocessor">     g_node_insert_before ((parent), NULL, (node))</font>
01075 <font class="preprocessor"></font><font class="preprocessor">#define g_node_insert_data(parent, position, data)      \</font>
01076 <font class="preprocessor">     g_node_insert ((parent), (position), g_node_new (data))</font>
01077 <font class="preprocessor"></font><font class="preprocessor">#define g_node_insert_data_before(parent, sibling, data)    \</font>
01078 <font class="preprocessor">     g_node_insert_before ((parent), (sibling), g_node_new (data))</font>
01079 <font class="preprocessor"></font><font class="preprocessor">#define g_node_prepend_data(parent, data)           \</font>
01080 <font class="preprocessor">     g_node_prepend ((parent), g_node_new (data))</font>
01081 <font class="preprocessor"></font><font class="preprocessor">#define g_node_append_data(parent, data)            \</font>
01082 <font class="preprocessor">     g_node_insert_before ((parent), NULL, g_node_new (data))</font>
01083 <font class="preprocessor"></font>
01084 <font class="comment">/* traversal function, assumes that `node' is root</font>
01085 <font class="comment"> * (only traverses `node' and its subtree).</font>
01086 <font class="comment"> * this function is just a high level interface to</font>
01087 <font class="comment"> * low level traversal functions, optimized for speed.</font>
01088 <font class="comment"> */</font>
01089 <font class="keywordtype">void</font>     g_node_traverse    (GNode        *root,
01090                  GTraverseType     order,
01091                  GTraverseFlags    flags,
01092                  gint          max_depth,
01093                  GNodeTraverseFunc func,
01094                  gpointer      data);
01095 
01096 <font class="comment">/* return the maximum tree height starting with `node', this is an expensive</font>
01097 <font class="comment"> * operation, since we need to visit all nodes. this could be shortened by</font>
01098 <font class="comment"> * adding `guint height' to struct _GNode, but then again, this is not very</font>
01099 <font class="comment"> * often needed, and would make g_node_insert() more time consuming.</font>
01100 <font class="comment"> */</font>
01101 guint    g_node_max_height   (GNode *root);
01102 
01103 <font class="keywordtype">void</font>     g_node_children_foreach (GNode       *node,
01104                   GTraverseFlags   flags,
01105                   GNodeForeachFunc func,
01106                   gpointer     data);
01107 <font class="keywordtype">void</font>     g_node_reverse_children (GNode       *node);
01108 guint    g_node_n_children   (GNode       *node);
01109 GNode*   g_node_nth_child    (GNode       *node,
01110                   guint        n);
01111 GNode*   g_node_last_child   (GNode       *node);
01112 GNode*   g_node_find_child   (GNode       *node,
01113                   GTraverseFlags   flags,
01114                   gpointer     data);
01115 gint     g_node_child_position   (GNode       *node,
01116                   GNode       *child);
01117 gint     g_node_child_index  (GNode       *node,
01118                   gpointer     data);
01119 
01120 GNode*   g_node_first_sibling    (GNode       *node);
01121 GNode*   g_node_last_sibling     (GNode       *node);
01122 
01123 <font class="preprocessor">#define  g_node_prev_sibling(node)  ((node) ? \</font>
01124 <font class="preprocessor">                     ((GNode*) (node))-&gt;prev : NULL)</font>
01125 <font class="preprocessor"></font><font class="preprocessor">#define  g_node_next_sibling(node)  ((node) ? \</font>
01126 <font class="preprocessor">                     ((GNode*) (node))-&gt;next : NULL)</font>
01127 <font class="preprocessor"></font><font class="preprocessor">#define  g_node_first_child(node)   ((node) ? \</font>
01128 <font class="preprocessor">                     ((GNode*) (node))-&gt;children : NULL)</font>
01129 <font class="preprocessor"></font>
01130 
01131 <font class="comment">/* Callback maintenance functions</font>
01132 <font class="comment"> */</font>
01133 <font class="preprocessor">#define G_HOOK_FLAG_USER_SHIFT  (4)</font>
01134 <font class="preprocessor"></font><font class="keyword">typedef</font> <font class="keyword">enum</font>
01135 {
01136   G_HOOK_FLAG_ACTIVE    = 1 &lt;&lt; 0,
01137   G_HOOK_FLAG_IN_CALL   = 1 &lt;&lt; 1,
01138   G_HOOK_FLAG_MASK  = 0x0f
01139 } GHookFlagMask;
01140 
01141 <font class="preprocessor">#define G_HOOK_DEFERRED_DESTROY ((GHookFreeFunc) 0x01)</font>
01142 <font class="preprocessor"></font>
01143 <font class="keyword">struct </font>_GHookList
01144 {
01145   guint      seq_id;
01146   guint      hook_size;
01147   guint      is_setup : 1;
01148   GHook     *hooks;
01149   GMemChunk *hook_memchunk;
01150   GHookFreeFunc  hook_free; <font class="comment">/* virtual function */</font>
01151   GHookFreeFunc  hook_destroy; <font class="comment">/* virtual function */</font>
01152 };
01153 
01154 <font class="keyword">struct </font>_GHook
01155 {
01156   gpointer   data;
01157   GHook     *next;
01158   GHook     *prev;
01159   guint      ref_count;
01160   guint      hook_id;
01161   guint      flags;
01162   gpointer   func;
01163   GDestroyNotify destroy;
01164 };
01165 
01166 <font class="preprocessor">#define G_HOOK_ACTIVE(hook)     ((((GHook*) hook)-&gt;flags &amp; \</font>
01167 <font class="preprocessor">                      G_HOOK_FLAG_ACTIVE) != 0)</font>
01168 <font class="preprocessor"></font><font class="preprocessor">#define G_HOOK_IN_CALL(hook)        ((((GHook*) hook)-&gt;flags &amp; \</font>
01169 <font class="preprocessor">                      G_HOOK_FLAG_IN_CALL) != 0)</font>
01170 <font class="preprocessor"></font><font class="preprocessor">#define G_HOOK_IS_VALID(hook)       (((GHook*) hook)-&gt;hook_id != 0 &amp;&amp; \</font>
01171 <font class="preprocessor">                     G_HOOK_ACTIVE (hook))</font>
01172 <font class="preprocessor"></font><font class="preprocessor">#define G_HOOK_IS_UNLINKED(hook)    (((GHook*) hook)-&gt;next == NULL &amp;&amp; \</font>
01173 <font class="preprocessor">                     ((GHook*) hook)-&gt;prev == NULL &amp;&amp; \</font>
01174 <font class="preprocessor">                     ((GHook*) hook)-&gt;hook_id == 0 &amp;&amp; \</font>
01175 <font class="preprocessor">                     ((GHook*) hook)-&gt;ref_count == 0)</font>
01176 <font class="preprocessor"></font>
01177 <font class="keywordtype">void</font>     g_hook_list_init       (GHookList      *hook_list,
01178                      guint           hook_size);
01179 <font class="keywordtype">void</font>     g_hook_list_clear      (GHookList      *hook_list);
01180 GHook*   g_hook_alloc           (GHookList      *hook_list);
01181 <font class="keywordtype">void</font>     g_hook_free            (GHookList      *hook_list,
01182                      GHook          *hook);
01183 <font class="keywordtype">void</font>     g_hook_ref         (GHookList      *hook_list,
01184                      GHook          *hook);
01185 <font class="keywordtype">void</font>     g_hook_unref           (GHookList      *hook_list,
01186                      GHook          *hook);
01187 gboolean g_hook_destroy         (GHookList      *hook_list,
01188                      guint           hook_id);
01189 <font class="keywordtype">void</font>     g_hook_destroy_link        (GHookList      *hook_list,
01190                      GHook          *hook);
01191 <font class="keywordtype">void</font>     g_hook_prepend         (GHookList      *hook_list,
01192                      GHook          *hook);
01193 <font class="keywordtype">void</font>     g_hook_insert_before       (GHookList      *hook_list,
01194                      GHook          *sibling,
01195                      GHook          *hook);
01196 <font class="keywordtype">void</font>     g_hook_insert_sorted       (GHookList      *hook_list,
01197                      GHook          *hook,
01198                      GHookCompareFunc    func);
01199 GHook*   g_hook_get         (GHookList      *hook_list,
01200                      guint           hook_id);
01201 GHook*   g_hook_find            (GHookList      *hook_list,
01202                      gboolean        need_valids,
01203                      GHookFindFunc       func,
01204                      gpointer        data);
01205 GHook*   g_hook_find_data       (GHookList      *hook_list,
01206                      gboolean        need_valids,
01207                      gpointer        data);
01208 GHook*   g_hook_find_func       (GHookList      *hook_list,
01209                      gboolean        need_valids,
01210                      gpointer        func);
01211 GHook*   g_hook_find_func_data      (GHookList      *hook_list,
01212                      gboolean        need_valids,
01213                      gpointer        func,
01214                      gpointer        data);
01215 <font class="comment">/* return the first valid hook, and increment its reference count */</font>
01216 GHook*   g_hook_first_valid     (GHookList      *hook_list,
01217                      gboolean        may_be_in_call);
01218 <font class="comment">/* return the next valid hook with incremented reference count, and</font>
01219 <font class="comment"> * decrement the reference count of the original hook</font>
01220 <font class="comment"> */</font>
01221 GHook*   g_hook_next_valid      (GHookList      *hook_list,
01222                      GHook          *hook,
01223                      gboolean        may_be_in_call);
01224 
01225 <font class="comment">/* GHookCompareFunc implementation to insert hooks sorted by their id */</font>
01226 gint     g_hook_compare_ids     (GHook          *new_hook,
01227                      GHook          *sibling);
01228 
01229 <font class="comment">/* convenience macros */</font>
01230 <font class="preprocessor">#define  g_hook_append( hook_list, hook )  \</font>
01231 <font class="preprocessor">     g_hook_insert_before ((hook_list), NULL, (hook))</font>
01232 <font class="preprocessor"></font>
01233 <font class="comment">/* invoke all valid hooks with the (*GHookFunc) signature.</font>
01234 <font class="comment"> */</font>
01235 <font class="keywordtype">void</font>     g_hook_list_invoke     (GHookList      *hook_list,
01236                      gboolean        may_recurse);
01237 <font class="comment">/* invoke all valid hooks with the (*GHookCheckFunc) signature,</font>
01238 <font class="comment"> * and destroy the hook if FALSE is returned.</font>
01239 <font class="comment"> */</font>
01240 <font class="keywordtype">void</font>     g_hook_list_invoke_check   (GHookList      *hook_list,
01241                      gboolean        may_recurse);
01242 <font class="comment">/* invoke a marshaller on all valid hooks.</font>
01243 <font class="comment"> */</font>
01244 <font class="keywordtype">void</font>     g_hook_list_marshal        (GHookList      *hook_list,
01245                      gboolean        may_recurse,
01246                      GHookMarshaller     marshaller,
01247                      gpointer        data);
01248 <font class="keywordtype">void</font>     g_hook_list_marshal_check  (GHookList      *hook_list,
01249                      gboolean        may_recurse,
01250                      GHookCheckMarshaller    marshaller,
01251                      gpointer        data);
01252 
01253 
01254 <font class="comment">/* Fatal error handlers.</font>
01255 <font class="comment"> * g_on_error_query() will prompt the user to either</font>
01256 <font class="comment"> * [E]xit, [H]alt, [P]roceed or show [S]tack trace.</font>
01257 <font class="comment"> * g_on_error_stack_trace() invokes gdb, which attaches to the current</font>
01258 <font class="comment"> * process and shows a stack trace.</font>
01259 <font class="comment"> * These function may cause different actions on non-unix platforms.</font>
01260 <font class="comment"> * The prg_name arg is required by gdb to find the executable, if it is</font>
01261 <font class="comment"> * passed as NULL, g_on_error_query() will try g_get_prgname().</font>
01262 <font class="comment"> */</font>
01263 <font class="keywordtype">void</font> g_on_error_query (<font class="keyword">const</font> gchar *prg_name);
01264 <font class="keywordtype">void</font> g_on_error_stack_trace (<font class="keyword">const</font> gchar *prg_name);
01265 
01266 
01267 <font class="comment">/* Logging mechanism</font>
01268 <font class="comment"> */</font>
01269 <font class="keyword">extern</font>          <font class="keyword">const</font> gchar     *g_log_domain_glib;
01270 guint       g_log_set_handler   (<font class="keyword">const</font> gchar    *log_domain,
01271                      GLogLevelFlags  log_levels,
01272                      GLogFunc    log_func,
01273                      gpointer    user_data);
01274 <font class="keywordtype">void</font>        g_log_remove_handler    (<font class="keyword">const</font> gchar    *log_domain,
01275                      guint       handler_id);
01276 <font class="keywordtype">void</font>        g_log_default_handler   (<font class="keyword">const</font> gchar    *log_domain,
01277                      GLogLevelFlags  log_level,
01278                      <font class="keyword">const</font> gchar    *message,
01279                      gpointer    unused_data);
01280 <font class="keywordtype">void</font>        g_log           (<font class="keyword">const</font> gchar    *log_domain,
01281                      GLogLevelFlags  log_level,
01282                      <font class="keyword">const</font> gchar    *format,
01283                      ...) G_GNUC_PRINTF (3, 4);
01284 <font class="keywordtype">void</font>        g_logv          (<font class="keyword">const</font> gchar    *log_domain,
01285                      GLogLevelFlags  log_level,
01286                      <font class="keyword">const</font> gchar    *format,
01287                      va_list     args);
01288 GLogLevelFlags  g_log_set_fatal_mask    (<font class="keyword">const</font> gchar    *log_domain,
01289                      GLogLevelFlags  fatal_mask);
01290 GLogLevelFlags  g_log_set_always_fatal  (GLogLevelFlags  fatal_mask);
01291 <font class="preprocessor">#ifndef G_LOG_DOMAIN</font>
01292 <font class="preprocessor"></font><font class="preprocessor">#define G_LOG_DOMAIN    ((gchar*) 0)</font>
01293 <font class="preprocessor"></font><font class="preprocessor">#endif  </font><font class="comment">/* G_LOG_DOMAIN */</font>
01294 <font class="preprocessor">#if defined (__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L</font>
01295 <font class="preprocessor"></font><font class="preprocessor">#define g_error(...)    g_log (G_LOG_DOMAIN,         \</font>
01296 <font class="preprocessor">                   G_LOG_LEVEL_ERROR,    \</font>
01297 <font class="preprocessor">                   __VA_ARGS__)</font>
01298 <font class="preprocessor"></font><font class="preprocessor">#define g_message(...)  g_log (G_LOG_DOMAIN,         \</font>
01299 <font class="preprocessor">                   G_LOG_LEVEL_MESSAGE,  \</font>
01300 <font class="preprocessor">                   __VA_ARGS__)</font>
01301 <font class="preprocessor"></font><font class="preprocessor">#define g_critical(...) g_log (G_LOG_DOMAIN,         \</font>
01302 <font class="preprocessor">                   G_LOG_LEVEL_CRITICAL, \</font>
01303 <font class="preprocessor">                   __VA_ARGS__)</font>
01304 <font class="preprocessor"></font><font class="preprocessor">#define g_warning(...)  g_log (G_LOG_DOMAIN,         \</font>
01305 <font class="preprocessor">                   G_LOG_LEVEL_WARNING,  \</font>
01306 <font class="preprocessor">                   __VA_ARGS__)</font>
01307 <font class="preprocessor"></font><font class="preprocessor">#elif defined (__GNUC__)</font>
01308 <font class="preprocessor"></font><font class="preprocessor">#define g_error(format...)  g_log (G_LOG_DOMAIN,         \</font>
01309 <font class="preprocessor">                       G_LOG_LEVEL_ERROR,    \</font>
01310 <font class="preprocessor">                       format)</font>
01311 <font class="preprocessor"></font><font class="preprocessor">#define g_message(format...)    g_log (G_LOG_DOMAIN,         \</font>
01312 <font class="preprocessor">                       G_LOG_LEVEL_MESSAGE,  \</font>
01313 <font class="preprocessor">                       format)</font>
01314 <font class="preprocessor"></font><font class="preprocessor">#define g_critical(format...)   g_log (G_LOG_DOMAIN,         \</font>
01315 <font class="preprocessor">                       G_LOG_LEVEL_CRITICAL, \</font>
01316 <font class="preprocessor">                       format)</font>
01317 <font class="preprocessor"></font><font class="preprocessor">#define g_warning(format...)    g_log (G_LOG_DOMAIN,         \</font>
01318 <font class="preprocessor">                       G_LOG_LEVEL_WARNING,  \</font>
01319 <font class="preprocessor">                       format)</font>
01320 <font class="preprocessor"></font><font class="preprocessor">#else   </font><font class="comment">/* !__GNUC__ */</font>
01321 <font class="keyword">static</font> <font class="keywordtype">void</font>
01322 g_error (<font class="keyword">const</font> gchar *format,
01323      ...)<font class="keyword"></font>
01324 <font class="keyword"></font>{
01325   va_list args;
01326   va_start (args, format);
01327   g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format, args);
01328   va_end (args);
01329 }
01330 <font class="keyword">static</font> <font class="keywordtype">void</font>
01331 g_message (<font class="keyword">const</font> gchar *format,
01332        ...)<font class="keyword"></font>
01333 <font class="keyword"></font>{
01334   va_list args;
01335   va_start (args, format);
01336   g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, format, args);
01337   va_end (args);
01338 }
01339 <font class="keyword">static</font> <font class="keywordtype">void</font>
01340 g_warning (<font class="keyword">const</font> gchar *format,
01341        ...)<font class="keyword"></font>
01342 <font class="keyword"></font>{
01343   va_list args;
01344   va_start (args, format);
01345   g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, format, args);
01346   va_end (args);
01347 }
01348 <font class="preprocessor">#endif  </font><font class="comment">/* !__GNUC__ */</font>
01349 
01350 <font class="keyword">typedef</font> void    (*GPrintFunc)       (<font class="keyword">const</font> gchar    *string);
01351 <font class="keywordtype">void</font>        g_print         (<font class="keyword">const</font> gchar    *format,
01352                      ...) G_GNUC_PRINTF (1, 2);
01353 GPrintFunc  g_set_print_handler (GPrintFunc  func);
01354 <font class="keywordtype">void</font>        g_printerr      (<font class="keyword">const</font> gchar    *format,
01355                      ...) G_GNUC_PRINTF (1, 2);
01356 GPrintFunc  g_set_printerr_handler  (GPrintFunc  func);
01357 
01358 <font class="comment">/* deprecated compatibility functions, use g_log_set_handler() instead */</font>
01359 <font class="keyword">typedef</font> void        (*GErrorFunc)       (<font class="keyword">const</font> gchar *str);
01360 <font class="keyword">typedef</font> void        (*GWarningFunc)     (<font class="keyword">const</font> gchar *str);
01361 GErrorFunc   g_set_error_handler   (GErrorFunc   func);
01362 GWarningFunc g_set_warning_handler (GWarningFunc func);
01363 GPrintFunc   g_set_message_handler (GPrintFunc func);
01364 
01365 
01366 <font class="comment">/* Memory allocation and debugging</font>
01367 <font class="comment"> */</font>
01368 <font class="preprocessor">#ifdef USE_DMALLOC</font>
01369 <font class="preprocessor"></font>
01370 <font class="preprocessor">#define g_malloc(size)       ((gpointer) MALLOC (size))</font>
01371 <font class="preprocessor"></font><font class="preprocessor">#define g_malloc0(size)      ((gpointer) CALLOC (char, size))</font>
01372 <font class="preprocessor"></font><font class="preprocessor">#define g_realloc(mem,size)  ((gpointer) REALLOC (mem, char, size))</font>
01373 <font class="preprocessor"></font><font class="preprocessor">#define g_free(mem)      FREE (mem)</font>
01374 <font class="preprocessor"></font>
01375 <font class="preprocessor">#else </font><font class="comment">/* !USE_DMALLOC */</font>
01376 
01377 gpointer g_malloc      (gulong    size);
01378 gpointer g_malloc0     (gulong    size);
01379 gpointer g_realloc     (gpointer  mem,
01380             gulong    size);
01381 <font class="keywordtype">void</font>     g_free        (gpointer  mem);
01382 
01383 <font class="preprocessor">#endif </font><font class="comment">/* !USE_DMALLOC */</font>
01384 
01385 <font class="keywordtype">void</font>     g_mem_profile (<font class="keywordtype">void</font>);
01386 <font class="keywordtype">void</font>     g_mem_check   (gpointer  mem);
01387 
01388 <font class="comment">/* Generic allocators</font>
01389 <font class="comment"> */</font>
01390 GAllocator* g_allocator_new   (<font class="keyword">const</font> gchar  *name,
01391                    guint         n_preallocs);
01392 <font class="keywordtype">void</font>        g_allocator_free  (GAllocator   *allocator);
01393 
01394 <font class="preprocessor">#define G_ALLOCATOR_LIST    (1)</font>
01395 <font class="preprocessor"></font><font class="preprocessor">#define G_ALLOCATOR_SLIST   (2)</font>
01396 <font class="preprocessor"></font><font class="preprocessor">#define G_ALLOCATOR_NODE    (3)</font>
01397 <font class="preprocessor"></font>
01398 
01399 <font class="comment">/* "g_mem_chunk_new" creates a new memory chunk.</font>
01400 <font class="comment"> * Memory chunks are used to allocate pieces of memory which are</font>
01401 <font class="comment"> *  always the same size. Lists are a good example of such a data type.</font>
01402 <font class="comment"> * The memory chunk allocates and frees blocks of memory as needed.</font>
01403 <font class="comment"> *  Just be sure to call "g_mem_chunk_free" and not "g_free" on data</font>
01404 <font class="comment"> *  allocated in a mem chunk. ("g_free" will most likely cause a seg</font>
01405 <font class="comment"> *  fault...somewhere).</font>
01406 <font class="comment"> *</font>
01407 <font class="comment"> * Oh yeah, GMemChunk is an opaque data type. (You don't really</font>
01408 <font class="comment"> *  want to know what's going on inside do you?)</font>
01409 <font class="comment"> */</font>
01410 
01411 <font class="comment">/* ALLOC_ONLY MemChunk's can only allocate memory. The free operation</font>
01412 <font class="comment"> *  is interpreted as a no op. ALLOC_ONLY MemChunk's save 4 bytes per</font>
01413 <font class="comment"> *  atom. (They are also useful for lists which use MemChunk to allocate</font>
01414 <font class="comment"> *  memory but are also part of the MemChunk implementation).</font>
01415 <font class="comment"> * ALLOC_AND_FREE MemChunk's can allocate and free memory.</font>
01416 <font class="comment"> */</font>
01417 
01418 <font class="preprocessor">#define G_ALLOC_ONLY      1</font>
01419 <font class="preprocessor"></font><font class="preprocessor">#define G_ALLOC_AND_FREE  2</font>
01420 <font class="preprocessor"></font>
01421 GMemChunk* g_mem_chunk_new     (gchar     *name,
01422                 gint       atom_size,
01423                 gulong     area_size,
01424                 gint       type);
01425 <font class="keywordtype">void</font>       g_mem_chunk_destroy (GMemChunk *mem_chunk);
01426 gpointer   g_mem_chunk_alloc   (GMemChunk *mem_chunk);
01427 gpointer   g_mem_chunk_alloc0  (GMemChunk *mem_chunk);
01428 <font class="keywordtype">void</font>       g_mem_chunk_free    (GMemChunk *mem_chunk,
01429                 gpointer   mem);
01430 <font class="keywordtype">void</font>       g_mem_chunk_clean   (GMemChunk *mem_chunk);
01431 <font class="keywordtype">void</font>       g_mem_chunk_reset   (GMemChunk *mem_chunk);
01432 <font class="keywordtype">void</font>       g_mem_chunk_print   (GMemChunk *mem_chunk);
01433 <font class="keywordtype">void</font>       g_mem_chunk_info    (<font class="keywordtype">void</font>);
01434 
01435 <font class="comment">/* Ah yes...we have a "g_blow_chunks" function.</font>
01436 <font class="comment"> * "g_blow_chunks" simply compresses all the chunks. This operation</font>
01437 <font class="comment"> *  consists of freeing every memory area that should be freed (but</font>
01438 <font class="comment"> *  which we haven't gotten around to doing yet). And, no,</font>
01439 <font class="comment"> *  "g_blow_chunks" doesn't follow the naming scheme, but it is a</font>
01440 <font class="comment"> *  much better name than "g_mem_chunk_clean_all" or something</font>
01441 <font class="comment"> *  similar.</font>
01442 <font class="comment"> */</font>
01443 <font class="keywordtype">void</font> g_blow_chunks (<font class="keywordtype">void</font>);
01444 
01445 
01446 <font class="comment">/* Timer</font>
01447 <font class="comment"> */</font>
01448 GTimer* g_timer_new (<font class="keywordtype">void</font>);
01449 <font class="keywordtype">void</font>    g_timer_destroy (GTimer  *timer);
01450 <font class="keywordtype">void</font>    g_timer_start   (GTimer  *timer);
01451 <font class="keywordtype">void</font>    g_timer_stop    (GTimer  *timer);
01452 <font class="keywordtype">void</font>    g_timer_reset   (GTimer  *timer);
01453 gdouble g_timer_elapsed (GTimer  *timer,
01454              gulong  *microseconds);
01455 
01456 
01457 <font class="comment">/* String utility functions that modify a string argument or</font>
01458 <font class="comment"> * return a constant string that must not be freed.</font>
01459 <font class="comment"> */</font>
01460 <font class="preprocessor">#define  G_STR_DELIMITERS   "_-|&gt; &lt;."</font>
01461 <font class="preprocessor"></font>gchar*   g_strdelimit       (gchar       *string,
01462                  <font class="keyword">const</font> gchar *delimiters,
01463                  gchar        new_delimiter);
01464 gdouble  g_strtod       (<font class="keyword">const</font> gchar *nptr,
01465                  gchar      **endptr);
01466 gchar*   g_strerror     (gint         errnum);
01467 gchar*   g_strsignal        (gint         signum);
01468 gint     g_strcasecmp       (<font class="keyword">const</font> gchar *s1,
01469                  <font class="keyword">const</font> gchar *s2);
01470 gint     g_strncasecmp      (<font class="keyword">const</font> gchar *s1,
01471                  <font class="keyword">const</font> gchar *s2,
01472                  guint        n);
01473 <font class="keywordtype">void</font>     g_strdown      (gchar       *string);
01474 <font class="keywordtype">void</font>     g_strup        (gchar       *string);
01475 <font class="keywordtype">void</font>     g_strreverse       (gchar       *string);
01476 <font class="comment">/* removes leading spaces */</font>
01477 gchar*   g_strchug              (gchar        *string);
01478 <font class="comment">/* removes trailing spaces */</font>
01479 gchar*  g_strchomp              (gchar        *string);
01480 <font class="comment">/* removes leading &amp; trailing spaces */</font>
01481 <font class="preprocessor">#define g_strstrip( string )    g_strchomp (g_strchug (string))</font>
01482 <font class="preprocessor"></font>
01483 <font class="comment">/* String utility functions that return a newly allocated string which</font>
01484 <font class="comment"> * ought to be freed from the caller at some point.</font>
01485 <font class="comment"> */</font>
01486 gchar*   g_strdup       (<font class="keyword">const</font> gchar *str);
01487 gchar*   g_strdup_printf    (<font class="keyword">const</font> gchar *format,
01488                  ...) G_GNUC_PRINTF (1, 2);
01489 gchar*   g_strdup_vprintf   (<font class="keyword">const</font> gchar *format,
01490                  va_list      args);
01491 gchar*   g_strndup      (<font class="keyword">const</font> gchar *str,
01492                  guint        n);
01493 gchar*   g_strnfill     (guint        length,
01494                  gchar        fill_char);
01495 gchar*   g_strconcat        (<font class="keyword">const</font> gchar *string1,
01496                  ...); <font class="comment">/* NULL terminated */</font>
01497 gchar*   g_strjoin      (<font class="keyword">const</font> gchar  *separator,
01498                  ...); <font class="comment">/* NULL terminated */</font>
01499 gchar*   g_strescape        (gchar        *string);
01500 gpointer g_memdup       (gconstpointer mem,
01501                  guint         byte_size);
01502 
01503 <font class="comment">/* NULL terminated string arrays.</font>
01504 <font class="comment"> * g_strsplit() splits up string into max_tokens tokens at delim and</font>
01505 <font class="comment"> * returns a newly allocated string array.</font>
01506 <font class="comment"> * g_strjoinv() concatenates all of str_array's strings, sliding in an</font>
01507 <font class="comment"> * optional separator, the returned string is newly allocated.</font>
01508 <font class="comment"> * g_strfreev() frees the array itself and all of its strings.</font>
01509 <font class="comment"> */</font>
01510 gchar**  g_strsplit     (<font class="keyword">const</font> gchar  *string,
01511                  <font class="keyword">const</font> gchar  *delimiter,
01512                  gint          max_tokens);
01513 gchar*   g_strjoinv     (<font class="keyword">const</font> gchar  *separator,
01514                  gchar       **str_array);
01515 <font class="keywordtype">void</font>     g_strfreev     (gchar       **str_array);
01516 
01517 
01518 
01519 <font class="comment">/* calculate a string size, guarranteed to fit format + args.</font>
01520 <font class="comment"> */</font>
01521 guint   g_printf_string_upper_bound (<font class="keyword">const</font> gchar* format,
01522                      va_list      args);
01523 
01524 
01525 <font class="comment">/* Retrive static string info</font>
01526 <font class="comment"> */</font>
01527 gchar*  g_get_user_name     (<font class="keywordtype">void</font>);
01528 gchar*  g_get_real_name     (<font class="keywordtype">void</font>);
01529 gchar*  g_get_home_dir      (<font class="keywordtype">void</font>);
01530 gchar*  g_get_tmp_dir       (<font class="keywordtype">void</font>);
01531 gchar*  g_get_prgname       (<font class="keywordtype">void</font>);
01532 <font class="keywordtype">void</font>    g_set_prgname       (<font class="keyword">const</font> gchar *prgname);
01533 
01534 
01535 <font class="comment">/* Miscellaneous utility functions</font>
01536 <font class="comment"> */</font>
01537 guint   g_parse_debug_string    (<font class="keyword">const</font> gchar *string,
01538                  GDebugKey   *keys,
01539                  guint        nkeys);
01540 gint    g_snprintf      (gchar       *string,
01541                  gulong       n,
01542                  gchar <font class="keyword">const</font> *format,
01543                  ...) G_GNUC_PRINTF (3, 4);
01544 gint    g_vsnprintf     (gchar       *string,
01545                  gulong       n,
01546                  gchar <font class="keyword">const</font> *format,
01547                  va_list      args);
01548 gchar*  g_basename      (<font class="keyword">const</font> gchar *file_name);
01549 <font class="comment">/* Check if a file name is an absolute path */</font>
01550 gboolean g_path_is_absolute (<font class="keyword">const</font> gchar *file_name);
01551 <font class="comment">/* In case of absolute paths, skip the root part */</font>
01552 gchar*  g_path_skip_root    (gchar       *file_name);
01553 
01554 <font class="comment">/* strings are newly allocated with g_malloc() */</font>
01555 gchar*  g_dirname       (<font class="keyword">const</font> gchar *file_name);
01556 gchar*  g_get_current_dir   (<font class="keywordtype">void</font>);
01557 
01558 <font class="comment">/* return the environment string for the variable. The returned memory</font>
01559 <font class="comment"> * must not be freed. */</font>
01560 gchar*  g_getenv        (<font class="keyword">const</font> gchar *variable);
01561 
01562 
01563 <font class="comment">/* we use a GLib function as a replacement for ATEXIT, so</font>
01564 <font class="comment"> * the programmer is not required to check the return value</font>
01565 <font class="comment"> * (if there is any in the implementation) and doesn't encounter</font>
01566 <font class="comment"> * missing include files.</font>
01567 <font class="comment"> */</font>
01568 <font class="keywordtype">void</font>    g_atexit        (GVoidFunc    func);
01569 
01570 
01571 <font class="comment">/* Bit tests</font>
01572 <font class="comment"> */</font>
01573 G_INLINE_FUNC gint  g_bit_nth_lsf (guint32 mask,
01574                        gint    nth_bit);
01575 <font class="preprocessor">#ifdef  G_CAN_INLINE</font>
01576 <font class="preprocessor"></font>G_INLINE_FUNC gint
01577 g_bit_nth_lsf (guint32 mask,
01578            gint    nth_bit)<font class="keyword"></font>
01579 <font class="keyword"></font>{
01580   <font class="keywordflow">do</font>
01581     {
01582       nth_bit++;
01583       <font class="keywordflow">if</font> (mask &amp; (1 &lt;&lt; (guint) nth_bit))
01584     <font class="keywordflow">return</font> nth_bit;
01585     }
01586   <font class="keywordflow">while</font> (nth_bit &lt; 32);
01587   <font class="keywordflow">return</font> -1;
01588 }
01589 <font class="preprocessor">#endif  </font><font class="comment">/* G_CAN_INLINE */</font>
01590 
01591 G_INLINE_FUNC gint  g_bit_nth_msf (guint32 mask,
01592                        gint    nth_bit);
01593 <font class="preprocessor">#ifdef G_CAN_INLINE</font>
01594 <font class="preprocessor"></font>G_INLINE_FUNC gint
01595 g_bit_nth_msf (guint32 mask,
01596            gint    nth_bit)<font class="keyword"></font>
01597 <font class="keyword"></font>{
01598   <font class="keywordflow">if</font> (nth_bit &lt; 0)
01599     nth_bit = 32;
01600   <font class="keywordflow">do</font>
01601     {
01602       nth_bit--;
01603       <font class="keywordflow">if</font> (mask &amp; (1 &lt;&lt; (guint) nth_bit))
01604     <font class="keywordflow">return</font> nth_bit;
01605     }
01606   <font class="keywordflow">while</font> (nth_bit &gt; 0);
01607   <font class="keywordflow">return</font> -1;
01608 }
01609 <font class="preprocessor">#endif  </font><font class="comment">/* G_CAN_INLINE */</font>
01610 
01611 G_INLINE_FUNC guint g_bit_storage (guint number);
01612 <font class="preprocessor">#ifdef G_CAN_INLINE</font>
01613 <font class="preprocessor"></font>G_INLINE_FUNC guint
01614 g_bit_storage (guint number)<font class="keyword"></font>
01615 <font class="keyword"></font>{
01616   <font class="keyword">register</font> guint n_bits = 0;
01617   
01618   <font class="keywordflow">do</font>
01619     {
01620       n_bits++;
01621       number &gt;&gt;= 1;
01622     }
01623   <font class="keywordflow">while</font> (number);
01624   <font class="keywordflow">return</font> n_bits;
01625 }
01626 <font class="preprocessor">#endif  </font><font class="comment">/* G_CAN_INLINE */</font>
01627 
01628 <font class="comment">/* String Chunks</font>
01629 <font class="comment"> */</font>
01630 GStringChunk* g_string_chunk_new       (gint size);
01631 <font class="keywordtype">void</font>          g_string_chunk_free      (GStringChunk *chunk);
01632 gchar*        g_string_chunk_insert    (GStringChunk *chunk,
01633                         <font class="keyword">const</font> gchar  *string);
01634 gchar*        g_string_chunk_insert_const  (GStringChunk *chunk,
01635                         <font class="keyword">const</font> gchar  *string);
01636 
01637 
01638 <font class="comment">/* Strings</font>
01639 <font class="comment"> */</font>
01640 GString* g_string_new       (<font class="keyword">const</font> gchar *init);
01641 GString* g_string_sized_new (guint    dfl_size);
01642 <font class="keywordtype">void</font>     g_string_free      (GString     *string,
01643                  gint     free_segment);
01644 GString* g_string_assign    (GString     *lval,
01645                  <font class="keyword">const</font> gchar *rval);
01646 GString* g_string_truncate  (GString     *string,
01647                  gint     len);
01648 GString* g_string_append    (GString     *string,
01649                  <font class="keyword">const</font> gchar *val);
01650 GString* g_string_append_c  (GString     *string,
01651                  gchar    c);
01652 GString* g_string_prepend   (GString     *string,
01653                  <font class="keyword">const</font> gchar *val);
01654 GString* g_string_prepend_c (GString     *string,
01655                  gchar    c);
01656 GString* g_string_insert    (GString     *string,
01657                  gint     pos,
01658                  <font class="keyword">const</font> gchar *val);
01659 GString* g_string_insert_c  (GString     *string,
01660                  gint     pos,
01661                  gchar    c);
01662 GString* g_string_erase     (GString     *string,
01663                  gint     pos,
01664                  gint     len);
01665 GString* g_string_down      (GString     *string);
01666 GString* g_string_up        (GString     *string);
01667 <font class="keywordtype">void</font>     g_string_sprintf   (GString     *string,
01668                  <font class="keyword">const</font> gchar *format,
01669                  ...) G_GNUC_PRINTF (2, 3);
01670 <font class="keywordtype">void</font>     g_string_sprintfa  (GString     *string,
01671                  <font class="keyword">const</font> gchar *format,
01672                  ...) G_GNUC_PRINTF (2, 3);
01673 
01674 
01675 <font class="comment">/* Resizable arrays, remove fills any cleared spot and shortens the</font>
01676 <font class="comment"> * array, while preserving the order. remove_fast will distort the</font>
01677 <font class="comment"> * order by moving the last element to the position of the removed </font>
01678 <font class="comment"> */</font>
01679 
01680 <font class="preprocessor">#define g_array_append_val(a,v)   g_array_append_vals (a, &amp;(v), 1)</font>
01681 <font class="preprocessor"></font><font class="preprocessor">#define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &amp;(v), 1)</font>
01682 <font class="preprocessor"></font><font class="preprocessor">#define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &amp;(v), 1)</font>
01683 <font class="preprocessor"></font><font class="preprocessor">#define g_array_index(a,t,i)      (((t*) (a)-&gt;data) [(i)])</font>
01684 <font class="preprocessor"></font>
01685 GArray* g_array_new           (gboolean     zero_terminated,
01686                    gboolean     clear,
01687                    guint        element_size);
01688 <font class="keywordtype">void</font>    g_array_free              (GArray      *array,
01689                    gboolean     free_segment);
01690 GArray* g_array_append_vals       (GArray      *array,
01691                    gconstpointer    data,
01692                    guint        len);
01693 GArray* g_array_prepend_vals      (GArray      *array,
01694                    gconstpointer    data,
01695                    guint        len);
01696 GArray* g_array_insert_vals       (GArray          *array,
01697                    guint            index,
01698                    gconstpointer    data,
01699                    guint            len);
01700 GArray* g_array_set_size          (GArray      *array,
01701                    guint        length);
01702 GArray* g_array_remove_index      (GArray      *array,
01703                    guint        index);
01704 GArray* g_array_remove_index_fast (GArray      *array,
01705                    guint        index);
01706 
01707 <font class="comment">/* Resizable pointer array.  This interface is much less complicated</font>
01708 <font class="comment"> * than the above.  Add appends appends a pointer.  Remove fills any</font>
01709 <font class="comment"> * cleared spot and shortens the array. remove_fast will again distort</font>
01710 <font class="comment"> * order.  </font>
01711 <font class="comment"> */</font>
01712 <font class="preprocessor">#define     g_ptr_array_index(array,index) (array-&gt;pdata)[index]</font>
01713 <font class="preprocessor"></font>GPtrArray*  g_ptr_array_new        (<font class="keywordtype">void</font>);
01714 <font class="keywordtype">void</font>        g_ptr_array_free           (GPtrArray   *array,
01715                         gboolean     free_seg);
01716 <font class="keywordtype">void</font>        g_ptr_array_set_size       (GPtrArray   *array,
01717                         gint     length);
01718 gpointer    g_ptr_array_remove_index       (GPtrArray   *array,
01719                         guint    index);
01720 gpointer    g_ptr_array_remove_index_fast  (GPtrArray   *array,
01721                         guint    index);
01722 gboolean    g_ptr_array_remove         (GPtrArray   *array,
01723                         gpointer     data);
01724 gboolean    g_ptr_array_remove_fast        (GPtrArray   *array,
01725                         gpointer     data);
01726 <font class="keywordtype">void</font>        g_ptr_array_add        (GPtrArray   *array,
01727                         gpointer     data);
01728 
01729 <font class="comment">/* Byte arrays, an array of guint8.  Implemented as a GArray,</font>
01730 <font class="comment"> * but type-safe.</font>
01731 <font class="comment"> */</font>
01732 
01733 GByteArray* g_byte_array_new               (<font class="keywordtype">void</font>);
01734 <font class="keywordtype">void</font>        g_byte_array_free              (GByteArray   *array,
01735                         gboolean      free_segment);
01736 GByteArray* g_byte_array_append            (GByteArray   *array,
01737                         <font class="keyword">const</font> guint8 *data,
01738                         guint     len);
01739 GByteArray* g_byte_array_prepend           (GByteArray   *array,
01740                         <font class="keyword">const</font> guint8 *data,
01741                         guint     len);
01742 GByteArray* g_byte_array_set_size          (GByteArray   *array,
01743                         guint     length);
01744 GByteArray* g_byte_array_remove_index      (GByteArray   *array,
01745                         guint     index);
01746 GByteArray* g_byte_array_remove_index_fast (GByteArray   *array,
01747                         guint     index);
01748 
01749 
01750 <font class="comment">/* Hash Functions</font>
01751 <font class="comment"> */</font>
01752 gint  g_str_equal (gconstpointer   v,
01753            gconstpointer   v2);
01754 guint g_str_hash  (gconstpointer   v);
01755 
01756 gint  g_int_equal (gconstpointer   v,
01757            gconstpointer   v2);
01758 guint g_int_hash  (gconstpointer   v);
01759 
01760 <font class="comment">/* This "hash" function will just return the key's adress as an</font>
01761 <font class="comment"> * unsigned integer. Useful for hashing on plain adresses or</font>
01762 <font class="comment"> * simple integer values.</font>
01763 <font class="comment"> * passing NULL into g_hash_table_new() as GHashFunc has the</font>
01764 <font class="comment"> * same effect as passing g_direct_hash().</font>
01765 <font class="comment"> */</font>
01766 guint g_direct_hash  (gconstpointer v);
01767 gint  g_direct_equal (gconstpointer v,
01768               gconstpointer v2);
01769 
01770 
01771 <font class="comment">/* Quarks (string&lt;-&gt;id association)</font>
01772 <font class="comment"> */</font>
01773 GQuark    g_quark_try_string        (<font class="keyword">const</font> gchar    *string);
01774 GQuark    g_quark_from_static_string    (<font class="keyword">const</font> gchar    *string);
01775 GQuark    g_quark_from_string       (<font class="keyword">const</font> gchar    *string);
01776 gchar*    g_quark_to_string     (GQuark      quark);
01777 
01778 
01779 <font class="comment">/* Keyed Data List</font>
01780 <font class="comment"> * NOTE: these functions are scheduled for a rename in GLib 1.3</font>
01781 <font class="comment"> */</font>
01782 <font class="keywordtype">void</font>      g_datalist_init        (GData      **datalist);
01783 <font class="keywordtype">void</font>      g_datalist_clear       (GData      **datalist);
01784 gpointer  g_datalist_id_get_data     (GData      **datalist,
01785                       GQuark       key_id);
01786 <font class="keywordtype">void</font>      g_datalist_id_set_data_full    (GData      **datalist,
01787                       GQuark       key_id,
01788                       gpointer     data,
01789                       GDestroyNotify   destroy_func);
01790 <font class="keywordtype">void</font>      g_datalist_id_remove_no_notify (GData      **datalist,
01791                       GQuark       key_id);
01792 <font class="keywordtype">void</font>      g_datalist_foreach         (GData      **datalist,
01793                       GDataForeachFunc func,
01794                       gpointer     user_data);
01795 <font class="preprocessor">#define   g_datalist_id_set_data(dl, q, d)  \</font>
01796 <font class="preprocessor">     g_datalist_id_set_data_full ((dl), (q), (d), NULL)</font>
01797 <font class="preprocessor"></font><font class="preprocessor">#define   g_datalist_id_remove_data(dl, q)  \</font>
01798 <font class="preprocessor">     g_datalist_id_set_data ((dl), (q), NULL)</font>
01799 <font class="preprocessor"></font><font class="preprocessor">#define   g_datalist_get_data(dl, k)        \</font>
01800 <font class="preprocessor">     (g_datalist_id_get_data ((dl), g_quark_try_string (k)))</font>
01801 <font class="preprocessor"></font><font class="preprocessor">#define   g_datalist_set_data_full(dl, k, d, f) \</font>
01802 <font class="preprocessor">     g_datalist_id_set_data_full ((dl), g_quark_from_string (k), (d), (f))</font>
01803 <font class="preprocessor"></font><font class="preprocessor">#define   g_datalist_remove_no_notify(dl, k)    \</font>
01804 <font class="preprocessor">     g_datalist_id_remove_no_notify ((dl), g_quark_try_string (k))</font>
01805 <font class="preprocessor"></font><font class="preprocessor">#define   g_datalist_set_data(dl, k, d)     \</font>
01806 <font class="preprocessor">     g_datalist_set_data_full ((dl), (k), (d), NULL)</font>
01807 <font class="preprocessor"></font><font class="preprocessor">#define   g_datalist_remove_data(dl, k)     \</font>
01808 <font class="preprocessor">     g_datalist_id_set_data ((dl), g_quark_try_string (k), NULL)</font>
01809 <font class="preprocessor"></font>
01810 
01811 <font class="comment">/* Location Associated Keyed Data</font>
01812 <font class="comment"> * NOTE: these functions are scheduled for a rename in GLib 1.3</font>
01813 <font class="comment"> */</font>
01814 <font class="keywordtype">void</font>      g_dataset_destroy     (gconstpointer    dataset_location);
01815 gpointer  g_dataset_id_get_data     (gconstpointer    dataset_location,
01816                      GQuark       key_id);
01817 <font class="keywordtype">void</font>      g_dataset_id_set_data_full    (gconstpointer    dataset_location,
01818                      GQuark       key_id,
01819                      gpointer     data,
01820                      GDestroyNotify   destroy_func);
01821 <font class="keywordtype">void</font>      g_dataset_id_remove_no_notify (gconstpointer    dataset_location,
01822                      GQuark       key_id);
01823 <font class="keywordtype">void</font>      g_dataset_foreach     (gconstpointer    dataset_location,
01824                      GDataForeachFunc func,
01825                      gpointer     user_data);
01826 <font class="preprocessor">#define   g_dataset_id_set_data(l, k, d)    \</font>
01827 <font class="preprocessor">     g_dataset_id_set_data_full ((l), (k), (d), NULL)</font>
01828 <font class="preprocessor"></font><font class="preprocessor">#define   g_dataset_id_remove_data(l, k)    \</font>
01829 <font class="preprocessor">     g_dataset_id_set_data ((l), (k), NULL)</font>
01830 <font class="preprocessor"></font><font class="preprocessor">#define   g_dataset_get_data(l, k)      \</font>
01831 <font class="preprocessor">     (g_dataset_id_get_data ((l), g_quark_try_string (k)))</font>
01832 <font class="preprocessor"></font><font class="preprocessor">#define   g_dataset_set_data_full(l, k, d, f)   \</font>
01833 <font class="preprocessor">     g_dataset_id_set_data_full ((l), g_quark_from_string (k), (d), (f))</font>
01834 <font class="preprocessor"></font><font class="preprocessor">#define   g_dataset_remove_no_notify(l, k)  \</font>
01835 <font class="preprocessor">     g_dataset_id_remove_no_notify ((l), g_quark_try_string (k))</font>
01836 <font class="preprocessor"></font><font class="preprocessor">#define   g_dataset_set_data(l, k, d)       \</font>
01837 <font class="preprocessor">     g_dataset_set_data_full ((l), (k), (d), NULL)</font>
01838 <font class="preprocessor"></font><font class="preprocessor">#define   g_dataset_remove_data(l, k)       \</font>
01839 <font class="preprocessor">     g_dataset_id_set_data ((l), g_quark_try_string (k), NULL)</font>
01840 <font class="preprocessor"></font>
01841 
01842 <font class="comment">/* GScanner: Flexible lexical scanner for general purpose.</font>
01843 <font class="comment"> */</font>
01844 
01845 <font class="comment">/* Character sets */</font>
01846 <font class="preprocessor">#define G_CSET_A_2_Z    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</font>
01847 <font class="preprocessor"></font><font class="preprocessor">#define G_CSET_a_2_z    "abcdefghijklmnopqrstuvwxyz"</font>
01848 <font class="preprocessor"></font><font class="preprocessor">#define G_CSET_LATINC   "\300\301\302\303\304\305\306"\</font>
01849 <font class="preprocessor">            "\307\310\311\312\313\314\315\316\317\320"\</font>
01850 <font class="preprocessor">            "\321\322\323\324\325\326"\</font>
01851 <font class="preprocessor">            "\330\331\332\333\334\335\336"</font>
01852 <font class="preprocessor"></font><font class="preprocessor">#define G_CSET_LATINS   "\337\340\341\342\343\344\345\346"\</font>
01853 <font class="preprocessor">            "\347\350\351\352\353\354\355\356\357\360"\</font>
01854 <font class="preprocessor">            "\361\362\363\364\365\366"\</font>
01855 <font class="preprocessor">            "\370\371\372\373\374\375\376\377"</font>
01856 <font class="preprocessor"></font>
01857 <font class="comment">/* Error types */</font>
01858 <font class="keyword">typedef</font> <font class="keyword">enum</font>
01859 {
01860   G_ERR_UNKNOWN,
01861   G_ERR_UNEXP_EOF,
01862   G_ERR_UNEXP_EOF_IN_STRING,
01863   G_ERR_UNEXP_EOF_IN_COMMENT,
01864   G_ERR_NON_DIGIT_IN_CONST,
01865   G_ERR_DIGIT_RADIX,
01866   G_ERR_FLOAT_RADIX,
01867   G_ERR_FLOAT_MALFORMED
01868 } GErrorType;
01869 
01870 <font class="comment">/* Token types */</font>
01871 <font class="keyword">typedef</font> <font class="keyword">enum</font>
01872 {
01873   G_TOKEN_EOF           =   0,
01874   
01875   G_TOKEN_LEFT_PAREN        = <font class="charliteral">'('</font>,
01876   G_TOKEN_RIGHT_PAREN       = <font class="charliteral">')'</font>,
01877   G_TOKEN_LEFT_CURLY        = <font class="charliteral">'{'</font>,
01878   G_TOKEN_RIGHT_CURLY       = <font class="charliteral">'}'</font>,
01879   G_TOKEN_LEFT_BRACE        = <font class="charliteral">'['</font>,
01880   G_TOKEN_RIGHT_BRACE       = <font class="charliteral">']'</font>,
01881   G_TOKEN_EQUAL_SIGN        = <font class="charliteral">'='</font>,
01882   G_TOKEN_COMMA         = <font class="charliteral">','</font>,
01883   
01884   G_TOKEN_NONE          = 256,
01885   
01886   G_TOKEN_ERROR,
01887   
01888   G_TOKEN_CHAR,
01889   G_TOKEN_BINARY,
01890   G_TOKEN_OCTAL,
01891   G_TOKEN_INT,
01892   G_TOKEN_HEX,
01893   G_TOKEN_FLOAT,
01894   G_TOKEN_STRING,
01895   
01896   G_TOKEN_SYMBOL,
01897   G_TOKEN_IDENTIFIER,
01898   G_TOKEN_IDENTIFIER_NULL,
01899   
01900   G_TOKEN_COMMENT_SINGLE,
01901   G_TOKEN_COMMENT_MULTI,
01902   G_TOKEN_LAST
01903 } GTokenType;
01904 
01905 <font class="keyword">union   </font>_GTokenValue
01906 {
01907   gpointer  v_symbol;
01908   gchar     *v_identifier;
01909   gulong    v_binary;
01910   gulong    v_octal;
01911   gulong    v_int;
01912   gdouble   v_float;
01913   gulong    v_hex;
01914   gchar     *v_string;
01915   gchar     *v_comment;
01916   guchar    v_char;
01917   guint     v_error;
01918 };
01919 
01920 <font class="keyword">struct  </font>_GScannerConfig
01921 {
01922   <font class="comment">/* Character sets</font>
01923 <font class="comment">   */</font>
01924   gchar     *cset_skip_characters;      <font class="comment">/* default: " \t\n" */</font>
01925   gchar     *cset_identifier_first;
01926   gchar     *cset_identifier_nth;
01927   gchar     *cpair_comment_single;      <font class="comment">/* default: "#\n" */</font>
01928   
01929   <font class="comment">/* Should symbol lookup work case sensitive?</font>
01930 <font class="comment">   */</font>
01931   guint     case_sensitive : 1;
01932   
01933   <font class="comment">/* Boolean values to be adjusted "on the fly"</font>
01934 <font class="comment">   * to configure scanning behaviour.</font>
01935 <font class="comment">   */</font>
01936   guint     skip_comment_multi : 1;     <font class="comment">/* C like comment */</font>
01937   guint     skip_comment_single : 1;    <font class="comment">/* single line comment */</font>
01938   guint     scan_comment_multi : 1;     <font class="comment">/* scan multi line comments? */</font>
01939   guint     scan_identifier : 1;
01940   guint     scan_identifier_1char : 1;
01941   guint     scan_identifier_NULL : 1;
01942   guint     scan_symbols : 1;
01943   guint     scan_binary : 1;
01944   guint     scan_octal : 1;
01945   guint     scan_float : 1;
01946   guint     scan_hex : 1;           <font class="comment">/* `0x0ff0' */</font>
01947   guint     scan_hex_dollar : 1;        <font class="comment">/* `$0ff0' */</font>
01948   guint     scan_string_sq : 1;     <font class="comment">/* string: 'anything' */</font>
01949   guint     scan_string_dq : 1;     <font class="comment">/* string: "\\-escapes!\n" */</font>
01950   guint     numbers_2_int : 1;      <font class="comment">/* bin, octal, hex =&gt; int */</font>
01951   guint     int_2_float : 1;        <font class="comment">/* int =&gt; G_TOKEN_FLOAT? */</font>
01952   guint     identifier_2_string : 1;
01953   guint     char_2_token : 1;       <font class="comment">/* return G_TOKEN_CHAR? */</font>
01954   guint     symbol_2_token : 1;
01955   guint     scope_0_fallback : 1;       <font class="comment">/* try scope 0 on lookups? */</font>
01956 };
01957 
01958 <font class="keyword">struct  </font>_GScanner
01959 {
01960   <font class="comment">/* unused fields */</font>
01961   gpointer      user_data;
01962   guint         max_parse_errors;
01963   
01964   <font class="comment">/* g_scanner_error() increments this field */</font>
01965   guint         parse_errors;
01966   
01967   <font class="comment">/* name of input stream, featured by the default message handler */</font>
01968   <font class="keyword">const</font> gchar       *input_name;
01969   
01970   <font class="comment">/* data pointer for derived structures */</font>
01971   gpointer      derived_data;
01972   
01973   <font class="comment">/* link into the scanner configuration */</font>
01974   GScannerConfig    *config;
01975   
01976   <font class="comment">/* fields filled in after g_scanner_get_next_token() */</font>
01977   GTokenType        token;
01978   GTokenValue       value;
01979   guint         line;
01980   guint         position;
01981   
01982   <font class="comment">/* fields filled in after g_scanner_peek_next_token() */</font>
01983   GTokenType        next_token;
01984   GTokenValue       next_value;
01985   guint         next_line;
01986   guint         next_position;
01987   
01988   <font class="comment">/* to be considered private */</font>
01989   GHashTable        *symbol_table;
01990   gint          input_fd;
01991   <font class="keyword">const</font> gchar       *text;
01992   <font class="keyword">const</font> gchar       *text_end;
01993   gchar         *buffer;
01994   guint         scope_id;
01995   
01996   <font class="comment">/* handler function for _warn and _error */</font>
01997   GScannerMsgFunc   msg_handler;
01998 };
01999 
02000 GScanner*   g_scanner_new           (GScannerConfig *config_templ);
02001 <font class="keywordtype">void</font>        g_scanner_destroy       (GScanner   *scanner);
02002 <font class="keywordtype">void</font>        g_scanner_input_file        (GScanner   *scanner,
02003                          gint       input_fd);
02004 <font class="keywordtype">void</font>        g_scanner_sync_file_offset  (GScanner   *scanner);
02005 <font class="keywordtype">void</font>        g_scanner_input_text        (GScanner   *scanner,
02006                          <font class="keyword">const</font>  gchar   *text,
02007                          guint      text_len);
02008 GTokenType  g_scanner_get_next_token    (GScanner   *scanner);
02009 GTokenType  g_scanner_peek_next_token   (GScanner   *scanner);
02010 GTokenType  g_scanner_cur_token     (GScanner   *scanner);
02011 GTokenValue g_scanner_cur_value     (GScanner   *scanner);
02012 guint       g_scanner_cur_line      (GScanner   *scanner);
02013 guint       g_scanner_cur_position      (GScanner   *scanner);
02014 gboolean    g_scanner_eof           (GScanner   *scanner);
02015 guint       g_scanner_set_scope     (GScanner   *scanner,
02016                          guint       scope_id);
02017 <font class="keywordtype">void</font>        g_scanner_scope_add_symbol  (GScanner   *scanner,
02018                          guint       scope_id,
02019                          <font class="keyword">const</font> gchar    *symbol,
02020                          gpointer   value);
02021 <font class="keywordtype">void</font>        g_scanner_scope_remove_symbol   (GScanner   *scanner,
02022                          guint       scope_id,
02023                          <font class="keyword">const</font> gchar    *symbol);
02024 gpointer    g_scanner_scope_lookup_symbol   (GScanner   *scanner,
02025                          guint       scope_id,
02026                          <font class="keyword">const</font> gchar    *symbol);
02027 <font class="keywordtype">void</font>        g_scanner_scope_foreach_symbol  (GScanner   *scanner,
02028                          guint       scope_id,
02029                          GHFunc      func,
02030                          gpointer    user_data);
02031 gpointer    g_scanner_lookup_symbol     (GScanner   *scanner,
02032                          <font class="keyword">const</font> gchar    *symbol);
02033 <font class="keywordtype">void</font>        g_scanner_freeze_symbol_table   (GScanner   *scanner);
02034 <font class="keywordtype">void</font>        g_scanner_thaw_symbol_table (GScanner   *scanner);
02035 <font class="keywordtype">void</font>        g_scanner_unexp_token       (GScanner   *scanner,
02036                          GTokenType expected_token,
02037                          <font class="keyword">const</font> gchar    *identifier_spec,
02038                          <font class="keyword">const</font> gchar    *symbol_spec,
02039                          <font class="keyword">const</font> gchar    *symbol_name,
02040                          <font class="keyword">const</font> gchar    *message,
02041                          gint        is_error);
02042 <font class="keywordtype">void</font>        g_scanner_error         (GScanner   *scanner,
02043                          <font class="keyword">const</font> gchar    *format,
02044                          ...) G_GNUC_PRINTF (2,3);
02045 <font class="keywordtype">void</font>        g_scanner_warn          (GScanner   *scanner,
02046                          <font class="keyword">const</font> gchar    *format,
02047                          ...) G_GNUC_PRINTF (2,3);
02048 gint        g_scanner_stat_mode     (<font class="keyword">const</font> gchar    *filename);
02049 <font class="comment">/* keep downward source compatibility */</font>
02050 <font class="preprocessor">#define     g_scanner_add_symbol( scanner, symbol, value )  G_STMT_START { \</font>
02051 <font class="preprocessor">  g_scanner_scope_add_symbol ((scanner), 0, (symbol), (value)); \</font>
02052 <font class="preprocessor">} G_STMT_END</font>
02053 <font class="preprocessor"></font><font class="preprocessor">#define     g_scanner_remove_symbol( scanner, symbol )  G_STMT_START { \</font>
02054 <font class="preprocessor">  g_scanner_scope_remove_symbol ((scanner), 0, (symbol)); \</font>
02055 <font class="preprocessor">} G_STMT_END</font>
02056 <font class="preprocessor"></font><font class="preprocessor">#define     g_scanner_foreach_symbol( scanner, func, data ) G_STMT_START { \</font>
02057 <font class="preprocessor">  g_scanner_scope_foreach_symbol ((scanner), 0, (func), (data)); \</font>
02058 <font class="preprocessor">} G_STMT_END</font>
02059 <font class="preprocessor"></font>
02060 
02061 <font class="comment">/* GCompletion</font>
02062 <font class="comment"> */</font>
02063 
02064 <font class="keyword">struct </font>_GCompletion
02065 {
02066   GList* items;
02067   GCompletionFunc func;
02068   
02069   gchar* prefix;
02070   GList* cache;
02071 };
02072 
02073 GCompletion* g_completion_new          (GCompletionFunc func);
02074 <font class="keywordtype">void</font>         g_completion_add_items    (GCompletion*    cmp,
02075                     GList*      items);
02076 <font class="keywordtype">void</font>         g_completion_remove_items (GCompletion*    cmp,
02077                     GList*      items);
02078 <font class="keywordtype">void</font>         g_completion_clear_items  (GCompletion*    cmp);
02079 GList*       g_completion_complete     (GCompletion*    cmp,
02080                     gchar*      prefix,
02081                     gchar**     new_prefix);
02082 <font class="keywordtype">void</font>         g_completion_free         (GCompletion*    cmp);
02083 
02084 
02085 <font class="comment">/* GDate</font>
02086 <font class="comment"> *</font>
02087 <font class="comment"> * Date calculations (not time for now, to be resolved). These are a</font>
02088 <font class="comment"> * mutant combination of Steffen Beyer's DateCalc routines</font>
02089 <font class="comment"> * (http://www.perl.com/CPAN/authors/id/STBEY/) and Jon Trowbridge's</font>
02090 <font class="comment"> * date routines (written for in-house software).  Written by Havoc</font>
02091 <font class="comment"> * Pennington &lt;hp@pobox.com&gt; </font>
02092 <font class="comment"> */</font>
02093 
02094 <font class="keyword">typedef</font> guint16 GDateYear;
02095 <font class="keyword">typedef</font> guint8  GDateDay;   <font class="comment">/* day of the month */</font>
02096 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GDate GDate;
02097 <font class="comment">/* make struct tm known without having to include time.h */</font>
02098 <font class="keyword">struct </font>tm;
02099 
02100 <font class="comment">/* enum used to specify order of appearance in parsed date strings */</font>
02101 <font class="keyword">typedef</font> <font class="keyword">enum</font>
02102 {
02103   G_DATE_DAY   = 0,
02104   G_DATE_MONTH = 1,
02105   G_DATE_YEAR  = 2
02106 } GDateDMY;
02107 
02108 <font class="comment">/* actual week and month values */</font>
02109 <font class="keyword">typedef</font> <font class="keyword">enum</font>
02110 {
02111   G_DATE_BAD_WEEKDAY  = 0,
02112   G_DATE_MONDAY       = 1,
02113   G_DATE_TUESDAY      = 2,
02114   G_DATE_WEDNESDAY    = 3,
02115   G_DATE_THURSDAY     = 4,
02116   G_DATE_FRIDAY       = 5,
02117   G_DATE_SATURDAY     = 6,
02118   G_DATE_SUNDAY       = 7
02119 } GDateWeekday;
02120 <font class="keyword">typedef</font> <font class="keyword">enum</font>
02121 {
02122   G_DATE_BAD_MONTH = 0,
02123   G_DATE_JANUARY   = 1,
02124   G_DATE_FEBRUARY  = 2,
02125   G_DATE_MARCH     = 3,
02126   G_DATE_APRIL     = 4,
02127   G_DATE_MAY       = 5,
02128   G_DATE_JUNE      = 6,
02129   G_DATE_JULY      = 7,
02130   G_DATE_AUGUST    = 8,
02131   G_DATE_SEPTEMBER = 9,
02132   G_DATE_OCTOBER   = 10,
02133   G_DATE_NOVEMBER  = 11,
02134   G_DATE_DECEMBER  = 12
02135 } GDateMonth;
02136 
02137 <font class="preprocessor">#define G_DATE_BAD_JULIAN 0U</font>
02138 <font class="preprocessor"></font><font class="preprocessor">#define G_DATE_BAD_DAY    0U</font>
02139 <font class="preprocessor"></font><font class="preprocessor">#define G_DATE_BAD_YEAR   0U</font>
02140 <font class="preprocessor"></font>
02141 <font class="comment">/* Note: directly manipulating structs is generally a bad idea, but</font>
02142 <font class="comment"> * in this case it's an *incredibly* bad idea, because all or part</font>
02143 <font class="comment"> * of this struct can be invalid at any given time. Use the functions,</font>
02144 <font class="comment"> * or you will get hosed, I promise.</font>
02145 <font class="comment"> */</font>
02146 <font class="keyword">struct </font>_GDate
02147 { 
02148   guint julian_days : 32; <font class="comment">/* julian days representation - we use a</font>
02149 <font class="comment">                           *  bitfield hoping that 64 bit platforms</font>
02150 <font class="comment">                           *  will pack this whole struct in one big</font>
02151 <font class="comment">                           *  int </font>
02152 <font class="comment">                           */</font>
02153 
02154   guint julian : 1;    <font class="comment">/* julian is valid */</font>
02155   guint dmy    : 1;    <font class="comment">/* dmy is valid */</font>
02156 
02157   <font class="comment">/* DMY representation */</font>
02158   guint day    : 6;  
02159   guint month  : 4; 
02160   guint year   : 16; 
02161 };
02162 
02163 <font class="comment">/* g_date_new() returns an invalid date, you then have to _set() stuff </font>
02164 <font class="comment"> * to get a usable object. You can also allocate a GDate statically,</font>
02165 <font class="comment"> * then call g_date_clear() to initialize.</font>
02166 <font class="comment"> */</font>
02167 GDate*       g_date_new                   (<font class="keywordtype">void</font>);
02168 GDate*       g_date_new_dmy               (GDateDay     day, 
02169                                            GDateMonth   month, 
02170                                            GDateYear    year);
02171 GDate*       g_date_new_julian            (guint32      julian_day);
02172 <font class="keywordtype">void</font>         g_date_free                  (GDate       *date);
02173 
02174 <font class="comment">/* check g_date_valid() after doing an operation that might fail, like</font>
02175 <font class="comment"> * _parse.  Almost all g_date operations are undefined on invalid</font>
02176 <font class="comment"> * dates (the exceptions are the mutators, since you need those to</font>
02177 <font class="comment"> * return to validity).  </font>
02178 <font class="comment"> */</font>
02179 gboolean     g_date_valid                 (GDate       *date);
02180 gboolean     g_date_valid_day             (GDateDay     day);
02181 gboolean     g_date_valid_month           (GDateMonth   month);
02182 gboolean     g_date_valid_year            (GDateYear    year);
02183 gboolean     g_date_valid_weekday         (GDateWeekday weekday);
02184 gboolean     g_date_valid_julian          (guint32      julian_date);
02185 gboolean     g_date_valid_dmy             (GDateDay     day,
02186                                            GDateMonth   month,
02187                                            GDateYear    year);
02188 
02189 GDateWeekday g_date_weekday               (GDate       *date);
02190 GDateMonth   g_date_month                 (GDate       *date);
02191 GDateYear    g_date_year                  (GDate       *date);
02192 GDateDay     g_date_day                   (GDate       *date);
02193 guint32      g_date_julian                (GDate       *date);
02194 guint        g_date_day_of_year           (GDate       *date);
02195 
02196 <font class="comment">/* First monday/sunday is the start of week 1; if we haven't reached</font>
02197 <font class="comment"> * that day, return 0. These are not ISO weeks of the year; that</font>
02198 <font class="comment"> * routine needs to be added.</font>
02199 <font class="comment"> * these functions return the number of weeks, starting on the</font>
02200 <font class="comment"> * corrsponding day</font>
02201 <font class="comment"> */</font>
02202 guint        g_date_monday_week_of_year   (GDate      *date);
02203 guint        g_date_sunday_week_of_year   (GDate      *date);
02204 
02205 <font class="comment">/* If you create a static date struct you need to clear it to get it</font>
02206 <font class="comment"> * in a sane state before use. You can clear a whole array at</font>
02207 <font class="comment"> * once with the ndates argument.</font>
02208 <font class="comment"> */</font>
02209 <font class="keywordtype">void</font>         g_date_clear                 (GDate       *date, 
02210                                            guint        n_dates);
02211 
02212 <font class="comment">/* The parse routine is meant for dates typed in by a user, so it</font>
02213 <font class="comment"> * permits many formats but tries to catch common typos. If your data</font>
02214 <font class="comment"> * needs to be strictly validated, it is not an appropriate function.</font>
02215 <font class="comment"> */</font>
02216 <font class="keywordtype">void</font>         g_date_set_parse             (GDate       *date,
02217                                            <font class="keyword">const</font> gchar *str);
02218 <font class="keywordtype">void</font>         g_date_set_time              (GDate       *date, 
02219                                            GTime        time);
02220 <font class="keywordtype">void</font>         g_date_set_month             (GDate       *date, 
02221                                            GDateMonth   month);
02222 <font class="keywordtype">void</font>         g_date_set_day               (GDate       *date, 
02223                                            GDateDay     day);
02224 <font class="keywordtype">void</font>         g_date_set_year              (GDate       *date,
02225                                            GDateYear    year);
02226 <font class="keywordtype">void</font>         g_date_set_dmy               (GDate       *date,
02227                                            GDateDay     day,
02228                                            GDateMonth   month,
02229                                            GDateYear    y);
02230 <font class="keywordtype">void</font>         g_date_set_julian            (GDate       *date,
02231                                            guint32      julian_date);
02232 gboolean     g_date_is_first_of_month     (GDate       *date);
02233 gboolean     g_date_is_last_of_month      (GDate       *date);
02234 
02235 <font class="comment">/* To go forward by some number of weeks just go forward weeks*7 days */</font>
02236 <font class="keywordtype">void</font>         g_date_add_days              (GDate       *date, 
02237                                            guint        n_days);
02238 <font class="keywordtype">void</font>         g_date_subtract_days         (GDate       *date, 
02239                                            guint        n_days);
02240 
02241 <font class="comment">/* If you add/sub months while day &gt; 28, the day might change */</font>
02242 <font class="keywordtype">void</font>         g_date_add_months            (GDate       *date,
02243                                            guint        n_months);
02244 <font class="keywordtype">void</font>         g_date_subtract_months       (GDate       *date,
02245                                            guint        n_months);
02246 
02247 <font class="comment">/* If it's feb 29, changing years can move you to the 28th */</font>
02248 <font class="keywordtype">void</font>         g_date_add_years             (GDate       *date,
02249                                            guint        n_years);
02250 <font class="keywordtype">void</font>         g_date_subtract_years        (GDate       *date,
02251                                            guint        n_years);
02252 gboolean     g_date_is_leap_year          (GDateYear    year);
02253 guint8       g_date_days_in_month         (GDateMonth   month, 
02254                                            GDateYear    year);
02255 guint8       g_date_monday_weeks_in_year  (GDateYear    year);
02256 guint8       g_date_sunday_weeks_in_year  (GDateYear    year);
02257 
02258 <font class="comment">/* qsort-friendly (with a cast...) */</font>
02259 gint         g_date_compare               (GDate       *lhs,
02260                                            GDate       *rhs);
02261 <font class="keywordtype">void</font>         g_date_to_struct_tm          (GDate       *date,
02262                                            <font class="keyword">struct</font> tm   *tm);
02263 
02264 <font class="comment">/* Just like strftime() except you can only use date-related formats.</font>
02265 <font class="comment"> *   Using a time format is undefined.</font>
02266 <font class="comment"> */</font>
02267 gsize        g_date_strftime              (gchar       *s,
02268                                            gsize        slen,
02269                                            <font class="keyword">const</font> gchar *format,
02270                                            GDate       *date);
02271 
02272 
02273 <font class="comment">/* GRelation</font>
02274 <font class="comment"> *</font>
02275 <font class="comment"> * Indexed Relations.  Imagine a really simple table in a</font>
02276 <font class="comment"> * database.  Relations are not ordered.  This data type is meant for</font>
02277 <font class="comment"> * maintaining a N-way mapping.</font>
02278 <font class="comment"> *</font>
02279 <font class="comment"> * g_relation_new() creates a relation with FIELDS fields</font>
02280 <font class="comment"> *</font>
02281 <font class="comment"> * g_relation_destroy() frees all resources</font>
02282 <font class="comment"> * g_tuples_destroy() frees the result of g_relation_select()</font>
02283 <font class="comment"> *</font>
02284 <font class="comment"> * g_relation_index() indexes relation FIELD with the provided</font>
02285 <font class="comment"> *   equality and hash functions.  this must be done before any</font>
02286 <font class="comment"> *   calls to insert are made.</font>
02287 <font class="comment"> *</font>
02288 <font class="comment"> * g_relation_insert() inserts a new tuple.  you are expected to</font>
02289 <font class="comment"> *   provide the right number of fields.</font>
02290 <font class="comment"> *</font>
02291 <font class="comment"> * g_relation_delete() deletes all relations with KEY in FIELD</font>
02292 <font class="comment"> * g_relation_select() returns ...</font>
02293 <font class="comment"> * g_relation_count() counts ...</font>
02294 <font class="comment"> */</font>
02295 
02296 GRelation* g_relation_new     (gint     fields);
02297 <font class="keywordtype">void</font>       g_relation_destroy (GRelation   *relation);
02298 <font class="keywordtype">void</font>       g_relation_index   (GRelation   *relation,
02299                    gint     field,
02300                    GHashFunc    hash_func,
02301                    GCompareFunc key_compare_func);
02302 <font class="keywordtype">void</font>       g_relation_insert  (GRelation   *relation,
02303                    ...);
02304 gint       g_relation_delete  (GRelation   *relation,
02305                    gconstpointer  key,
02306                    gint     field);
02307 GTuples*   g_relation_select  (GRelation   *relation,
02308                    gconstpointer  key,
02309                    gint     field);
02310 gint       g_relation_count   (GRelation   *relation,
02311                    gconstpointer  key,
02312                    gint     field);
02313 gboolean   g_relation_exists  (GRelation   *relation,
02314                    ...);
02315 <font class="keywordtype">void</font>       g_relation_print   (GRelation   *relation);
02316 
02317 <font class="keywordtype">void</font>       g_tuples_destroy   (GTuples     *tuples);
02318 gpointer   g_tuples_index     (GTuples     *tuples,
02319                    gint     index,
02320                    gint     field);
02321 
02322 
02323 <font class="comment">/* Prime numbers.</font>
02324 <font class="comment"> */</font>
02325 
02326 <font class="comment">/* This function returns prime numbers spaced by approximately 1.5-2.0</font>
02327 <font class="comment"> * and is for use in resizing data structures which prefer</font>
02328 <font class="comment"> * prime-valued sizes.  The closest spaced prime function returns the</font>
02329 <font class="comment"> * next largest prime, or the highest it knows about which is about</font>
02330 <font class="comment"> * MAXINT/4.</font>
02331 <font class="comment"> */</font>
02332 guint      g_spaced_primes_closest (guint num);
02333 
02334 
02335 <font class="comment">/* GIOChannel</font>
02336 <font class="comment"> */</font>
02337 
02338 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GIOFuncs GIOFuncs;
02339 <font class="keyword">typedef</font> <font class="keyword">enum</font>
02340 {
02341   G_IO_ERROR_NONE,
02342   G_IO_ERROR_AGAIN,
02343   G_IO_ERROR_INVAL,
02344   G_IO_ERROR_UNKNOWN
02345 } GIOError;
02346 <font class="keyword">typedef</font> <font class="keyword">enum</font>
02347 {
02348   G_SEEK_CUR,
02349   G_SEEK_SET,
02350   G_SEEK_END
02351 } GSeekType;
02352 <font class="keyword">typedef</font> <font class="keyword">enum</font>
02353 {
02354   G_IO_IN   GLIB_SYSDEF_POLLIN,
02355   G_IO_OUT  GLIB_SYSDEF_POLLOUT,
02356   G_IO_PRI  GLIB_SYSDEF_POLLPRI,
02357   G_IO_ERR  GLIB_SYSDEF_POLLERR,
02358   G_IO_HUP  GLIB_SYSDEF_POLLHUP,
02359   G_IO_NVAL GLIB_SYSDEF_POLLNVAL
02360 } GIOCondition;
02361 
02362 <font class="keyword">struct </font>_GIOChannel
02363 {
02364   guint channel_flags;
02365   guint ref_count;
02366   GIOFuncs *funcs;
02367 };
02368 
02369 <font class="keyword">typedef</font> gboolean (*GIOFunc) (GIOChannel   *source,
02370                  GIOCondition  condition,
02371                  gpointer      data);
02372 <font class="keyword">struct </font>_GIOFuncs
02373 {
02374   GIOError (*io_read)   (GIOChannel     *channel, 
02375                  gchar          *buf, 
02376                  guint           count,
02377              guint          *bytes_read);
02378   GIOError (*io_write)  (GIOChannel     *channel, 
02379              gchar          *buf, 
02380              guint           count,
02381              guint          *bytes_written);
02382   GIOError (*io_seek)   (GIOChannel     *channel, 
02383              gint            offset, 
02384              GSeekType       type);
02385   void (*io_close)      (GIOChannel *channel);
02386   guint (*io_add_watch) (GIOChannel     *channel,
02387              gint            priority,
02388              GIOCondition    condition,
02389              GIOFunc         func,
02390              gpointer        user_data,
02391              GDestroyNotify  notify);
02392   void (*io_free)       (GIOChannel *channel);
02393 };
02394 
02395 <font class="keywordtype">void</font>        g_io_channel_init   (GIOChannel    *channel);
02396 <font class="keywordtype">void</font>        g_io_channel_ref    (GIOChannel    *channel);
02397 <font class="keywordtype">void</font>        g_io_channel_unref  (GIOChannel    *channel);
02398 GIOError    g_io_channel_read   (GIOChannel    *channel, 
02399                      gchar         *buf, 
02400                      guint          count,
02401                      guint         *bytes_read);
02402 GIOError  g_io_channel_write    (GIOChannel    *channel, 
02403                      gchar         *buf, 
02404                      guint          count,
02405                      guint         *bytes_written);
02406 GIOError  g_io_channel_seek     (GIOChannel    *channel,
02407                      gint           offset, 
02408                      GSeekType      type);
02409 <font class="keywordtype">void</font>      g_io_channel_close    (GIOChannel    *channel);
02410 guint     g_io_add_watch_full   (GIOChannel    *channel,
02411                      gint           priority,
02412                      GIOCondition   condition,
02413                      GIOFunc        func,
02414                      gpointer       user_data,
02415                      GDestroyNotify notify);
02416 guint    g_io_add_watch         (GIOChannel    *channel,
02417                      GIOCondition   condition,
02418                      GIOFunc        func,
02419                      gpointer       user_data);
02420 
02421 
02422 <font class="comment">/* Main loop</font>
02423 <font class="comment"> */</font>
02424 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GTimeVal    GTimeVal;
02425 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GSourceFuncs    GSourceFuncs;
02426 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GMainLoop   GMainLoop;  <font class="comment">/* Opaque */</font>
02427 
02428 <font class="keyword">struct </font>_GTimeVal
02429 {
02430   glong tv_sec;
02431   glong tv_usec;
02432 };
02433 <font class="keyword">struct </font>_GSourceFuncs
02434 {
02435   gboolean (*prepare)  (gpointer  source_data, 
02436             GTimeVal *current_time,
02437             gint     *timeout,
02438             gpointer  user_data);
02439   gboolean (*check)    (gpointer  source_data,
02440             GTimeVal *current_time,
02441             gpointer  user_data);
02442   gboolean (*dispatch) (gpointer  source_data, 
02443             GTimeVal *dispatch_time,
02444             gpointer  user_data);
02445   GDestroyNotify destroy;
02446 };
02447 
02448 <font class="comment">/* Standard priorities */</font>
02449 
02450 <font class="preprocessor">#define G_PRIORITY_HIGH            -100</font>
02451 <font class="preprocessor"></font><font class="preprocessor">#define G_PRIORITY_DEFAULT          0</font>
02452 <font class="preprocessor"></font><font class="preprocessor">#define G_PRIORITY_HIGH_IDLE        100</font>
02453 <font class="preprocessor"></font><font class="preprocessor">#define G_PRIORITY_DEFAULT_IDLE     200</font>
02454 <font class="preprocessor"></font><font class="preprocessor">#define G_PRIORITY_LOW              300</font>
02455 <font class="preprocessor"></font>
02456 <font class="keyword">typedef</font> gboolean (*GSourceFunc) (gpointer data);
02457 
02458 <font class="comment">/* Hooks for adding to the main loop */</font>
02459 guint    g_source_add                        (gint           priority, 
02460                           gboolean       can_recurse,
02461                           GSourceFuncs  *funcs,
02462                           gpointer       source_data, 
02463                           gpointer       user_data,
02464                           GDestroyNotify notify);
02465 gboolean g_source_remove                     (guint          tag);
02466 gboolean g_source_remove_by_user_data        (gpointer       user_data);
02467 gboolean g_source_remove_by_source_data      (gpointer       source_data);
02468 gboolean g_source_remove_by_funcs_user_data  (GSourceFuncs  *funcs,
02469                           gpointer       user_data);
02470 
02471 <font class="keywordtype">void</font> g_get_current_time             (GTimeVal   *result);
02472 
02473 <font class="comment">/* Running the main loop */</font>
02474 GMainLoop*  g_main_new      (gboolean    is_running);
02475 <font class="keywordtype">void</font>        g_main_run      (GMainLoop  *loop);
02476 <font class="keywordtype">void</font>        g_main_quit     (GMainLoop  *loop);
02477 <font class="keywordtype">void</font>        g_main_destroy      (GMainLoop  *loop);
02478 gboolean    g_main_is_running   (GMainLoop  *loop);
02479 
02480 <font class="comment">/* Run a single iteration of the mainloop. If block is FALSE,</font>
02481 <font class="comment"> * will never block</font>
02482 <font class="comment"> */</font>
02483 gboolean    g_main_iteration    (gboolean   may_block);
02484 
02485 <font class="comment">/* See if any events are pending */</font>
02486 gboolean    g_main_pending      (<font class="keywordtype">void</font>);
02487 
02488 <font class="comment">/* Idles and timeouts */</font>
02489 guint       g_timeout_add_full  (gint           priority,
02490                      guint          interval, 
02491                      GSourceFunc    function,
02492                      gpointer       data,
02493                      GDestroyNotify notify);
02494 guint       g_timeout_add       (guint          interval,
02495                      GSourceFunc    function,
02496                      gpointer       data);
02497 guint       g_idle_add      (GSourceFunc    function,
02498                      gpointer   data);
02499 guint       g_idle_add_full     (gint       priority,
02500                      GSourceFunc    function,
02501                      gpointer   data,
02502                      GDestroyNotify destroy);
02503 gboolean    g_idle_remove_by_data   (gpointer   data);
02504 
02505 <font class="comment">/* GPollFD</font>
02506 <font class="comment"> *</font>
02507 <font class="comment"> * System-specific IO and main loop calls</font>
02508 <font class="comment"> *</font>
02509 <font class="comment"> * On Win32, the fd in a GPollFD should be Win32 HANDLE (*not* a file</font>
02510 <font class="comment"> * descriptor as provided by the C runtime) that can be used by</font>
02511 <font class="comment"> * MsgWaitForMultipleObjects. This does *not* include file handles</font>
02512 <font class="comment"> * from CreateFile, SOCKETs, nor pipe handles. (But you can use</font>
02513 <font class="comment"> * WSAEventSelect to signal events when a SOCKET is readable).</font>
02514 <font class="comment"> *</font>
02515 <font class="comment"> * On Win32, fd can also be the special value G_WIN32_MSG_HANDLE to</font>
02516 <font class="comment"> * indicate polling for messages. These message queue GPollFDs should</font>
02517 <font class="comment"> * be added with the g_main_poll_win32_msg_add function.</font>
02518 <font class="comment"> *</font>
02519 <font class="comment"> * But note that G_WIN32_MSG_HANDLE GPollFDs should not be used by GDK</font>
02520 <font class="comment"> * (GTK) programs, as GDK itself wants to read messages and convert them</font>
02521 <font class="comment"> * to GDK events.</font>
02522 <font class="comment"> *</font>
02523 <font class="comment"> * So, unless you really know what you are doing, it's best not to try</font>
02524 <font class="comment"> * to use the main loop polling stuff for your own needs on</font>
02525 <font class="comment"> * Win32. It's really only written for the GIMP's needs so</font>
02526 <font class="comment"> * far.</font>
02527 <font class="comment"> */</font>
02528 
02529 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GPollFD GPollFD;
02530 <font class="keyword">typedef</font> gint    (*GPollFunc)    (GPollFD *ufds,
02531                  guint    nfsd,
02532                  gint     timeout);
02533 <font class="keyword">struct </font>_GPollFD
02534 {
02535   gint      fd;
02536   gushort   events;
02537   gushort   revents;
02538 };
02539 
02540 <font class="keywordtype">void</font>        g_main_add_poll          (GPollFD    *fd,
02541                       gint        priority);
02542 <font class="keywordtype">void</font>        g_main_remove_poll       (GPollFD    *fd);
02543 <font class="keywordtype">void</font>        g_main_set_poll_func     (GPollFunc   func);
02544 
02545 <font class="comment">/* On Unix, IO channels created with this function for any file</font>
02546 <font class="comment"> * descriptor or socket.</font>
02547 <font class="comment"> *</font>
02548 <font class="comment"> * On Win32, use this only for plain files opened with the MSVCRT (the</font>
02549 <font class="comment"> * Microsoft run-time C library) _open(), including file descriptors</font>
02550 <font class="comment"> * 0, 1 and 2 (corresponding to stdin, stdout and stderr).</font>
02551 <font class="comment"> * Actually, don't do even that, this code isn't done yet.</font>
02552 <font class="comment"> *</font>
02553 <font class="comment"> * The term file descriptor as used in the context of Win32 refers to</font>
02554 <font class="comment"> * the emulated Unix-like file descriptors MSVCRT provides.</font>
02555 <font class="comment"> */</font>
02556 GIOChannel* g_io_channel_unix_new    (<font class="keywordtype">int</font>         fd);
02557 gint        g_io_channel_unix_get_fd (GIOChannel *channel);
02558 
02559 <font class="preprocessor">#ifdef NATIVE_WIN32</font>
02560 <font class="preprocessor"></font>
02561 GUTILS_C_VAR guint g_pipe_readable_msg;
02562 
02563 <font class="preprocessor">#define G_WIN32_MSG_HANDLE 19981206</font>
02564 <font class="preprocessor"></font>
02565 <font class="comment">/* This is used to add polling for Windows messages. GDK (GTk+) programs</font>
02566 <font class="comment"> * should *not* use this. (In fact, I can't think of any program that</font>
02567 <font class="comment"> * would want to use this, but it's here just for completeness's sake.</font>
02568 <font class="comment"> */</font>
02569 <font class="keywordtype">void</font>        g_main_poll_win32_msg_add(gint        priority,
02570                       GPollFD    *fd,
02571                       guint       hwnd);
02572 
02573 <font class="comment">/* An IO channel for Windows messages for window handle hwnd. */</font>
02574 GIOChannel *g_io_channel_win32_new_messages (guint hwnd);
02575 
02576 <font class="comment">/* An IO channel for an anonymous pipe as returned from the MSVCRT</font>
02577 <font class="comment"> * _pipe(), with no mechanism for the writer to tell the reader when</font>
02578 <font class="comment"> * there is data in the pipe.</font>
02579 <font class="comment"> *</font>
02580 <font class="comment"> * This is not really implemented yet.</font>
02581 <font class="comment"> */</font>
02582 GIOChannel *g_io_channel_win32_new_pipe (<font class="keywordtype">int</font> fd);
02583 
02584 <font class="comment">/* An IO channel for a pipe as returned from the MSVCRT _pipe(), with</font>
02585 <font class="comment"> * Windows user messages used to signal data in the pipe for the</font>
02586 <font class="comment"> * reader.</font>
02587 <font class="comment"> *</font>
02588 <font class="comment"> * fd is the file descriptor. For the write end, peer is the thread id</font>
02589 <font class="comment"> * of the reader, and peer_fd is his file descriptor for the read end</font>
02590 <font class="comment"> * of the pipe.</font>
02591 <font class="comment"> *</font>
02592 <font class="comment"> * This is used by the GIMP, and works.</font>
02593 <font class="comment"> */</font>
02594 GIOChannel *g_io_channel_win32_new_pipe_with_wakeups (<font class="keywordtype">int</font>   fd,
02595                               guint peer,
02596                               <font class="keywordtype">int</font>   peer_fd);
02597 
02598 <font class="keywordtype">void</font>        g_io_channel_win32_pipe_request_wakeups (GIOChannel *channel,
02599                              guint       peer,
02600                              <font class="keywordtype">int</font>         peer_fd);
02601 
02602 <font class="keywordtype">void</font>        g_io_channel_win32_pipe_readable (<font class="keywordtype">int</font>   fd,
02603                           guint offset);
02604 
02605 <font class="comment">/* Get the C runtime file descriptor of a channel. */</font>
02606 gint        g_io_channel_win32_get_fd (GIOChannel *channel);
02607 
02608 <font class="comment">/* An IO channel for a SOCK_STREAM winsock socket. The parameter is</font>
02609 <font class="comment"> * actually a SOCKET.</font>
02610 <font class="comment"> */</font>
02611 GIOChannel *g_io_channel_win32_new_stream_socket (<font class="keywordtype">int</font> socket);
02612 
02613 <font class="preprocessor">#endif</font>
02614 <font class="preprocessor"></font>
02615 <font class="comment">/* Windows emulation stubs for common Unix functions</font>
02616 <font class="comment"> */</font>
02617 <font class="preprocessor">#ifdef NATIVE_WIN32</font>
02618 <font class="preprocessor"></font><font class="preprocessor">#  define MAXPATHLEN 1024</font>
02619 <font class="preprocessor"></font><font class="preprocessor">#  ifdef _MSC_VER</font>
02620 <font class="preprocessor"></font><font class="keyword">typedef</font> <font class="keywordtype">int</font> pid_t;
02621 
02622 <font class="comment">/* These POSIXish functions are available in the Microsoft C library</font>
02623 <font class="comment"> * prefixed with underscore (which of course technically speaking is</font>
02624 <font class="comment"> * the Right Thing, as they are non-ANSI. Not that being non-ANSI</font>
02625 <font class="comment"> * prevents Microsoft from practically requiring you to include</font>
02626 <font class="comment"> * &lt;windows.h&gt; every now and then...).</font>
02627 <font class="comment"> *</font>
02628 <font class="comment"> * You still need to include the appropriate headers to get the</font>
02629 <font class="comment"> * prototypes, &lt;io.h&gt; or &lt;direct.h&gt;.</font>
02630 <font class="comment"> *</font>
02631 <font class="comment"> * For some functions, we provide emulators in glib, which are prefixed</font>
02632 <font class="comment"> * with gwin_.</font>
02633 <font class="comment"> */</font>
02634 <font class="preprocessor">#    define getcwd      _getcwd</font>
02635 <font class="preprocessor"></font><font class="preprocessor">#    define getpid      _getpid</font>
02636 <font class="preprocessor"></font><font class="preprocessor">#    define access      _access</font>
02637 <font class="preprocessor"></font><font class="preprocessor">#    define open        _open</font>
02638 <font class="preprocessor"></font><font class="preprocessor">#    define read        _read</font>
02639 <font class="preprocessor"></font><font class="preprocessor">#    define write       _write</font>
02640 <font class="preprocessor"></font><font class="preprocessor">#    define lseek       _lseek</font>
02641 <font class="preprocessor"></font><font class="preprocessor">#    define close       _close</font>
02642 <font class="preprocessor"></font><font class="preprocessor">#    define pipe(phandles)  _pipe (phandles, 4096, _O_BINARY)</font>
02643 <font class="preprocessor"></font><font class="preprocessor">#    define popen       _popen</font>
02644 <font class="preprocessor"></font><font class="preprocessor">#    define pclose      _pclose</font>
02645 <font class="preprocessor"></font><font class="preprocessor">#    define fdopen      _fdopen</font>
02646 <font class="preprocessor"></font><font class="preprocessor">#    define ftruncate(fd, size) gwin_ftruncate (fd, size)</font>
02647 <font class="preprocessor"></font><font class="preprocessor">#    define opendir     gwin_opendir</font>
02648 <font class="preprocessor"></font><font class="preprocessor">#    define readdir     gwin_readdir</font>
02649 <font class="preprocessor"></font><font class="preprocessor">#    define rewinddir       gwin_rewinddir</font>
02650 <font class="preprocessor"></font><font class="preprocessor">#    define closedir        gwin_closedir</font>
02651 <font class="preprocessor"></font><font class="preprocessor">#    define NAME_MAX 255</font>
02652 <font class="preprocessor"></font><font class="keyword">struct </font>DIR
02653 {
02654   gchar    *dir_name;
02655   gboolean  just_opened;
02656   guint     find_file_handle;
02657   gpointer  find_file_data;
02658 };
02659 <font class="keyword">typedef</font> <font class="keyword">struct </font>DIR DIR;
02660 <font class="keyword">struct </font>dirent
02661 {
02662   gchar  d_name[NAME_MAX + 1];
02663 };
02664 <font class="comment">/* emulation functions */</font>
02665 <font class="keyword">extern</font> <font class="keywordtype">int</font>  gwin_ftruncate  (gint        f,
02666                  guint       size);
02667 DIR*        gwin_opendir    (<font class="keyword">const</font> gchar    *dirname);
02668 <font class="keyword">struct </font>dirent*  gwin_readdir    (DIR        *dir);
02669 <font class="keywordtype">void</font>        gwin_rewinddir  (DIR        *dir);
02670 gint        gwin_closedir   (DIR        *dir);
02671 <font class="preprocessor">#  endif </font><font class="comment">/* _MSC_VER */</font>
02672 <font class="preprocessor">#endif   </font><font class="comment">/* NATIVE_WIN32 */</font>
02673 
02674 
02675 <font class="comment">/* GLib Thread support</font>
02676 <font class="comment"> */</font>
02677 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GMutex      GMutex;
02678 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GCond       GCond;
02679 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GPrivate    GPrivate;
02680 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GStaticPrivate  GStaticPrivate;
02681 <font class="keyword">typedef</font> <font class="keyword">struct </font>_GThreadFunctions GThreadFunctions;
02682 <font class="keyword">struct </font>_GThreadFunctions
02683 {
02684   GMutex*  (*mutex_new)       (<font class="keywordtype">void</font>);
02685   void     (*mutex_lock)      (GMutex       *mutex);
02686   gboolean (*mutex_trylock)   (GMutex       *mutex);
02687   void     (*mutex_unlock)    (GMutex       *mutex);
02688   void     (*mutex_free)      (GMutex       *mutex);
02689   GCond*   (*cond_new)        (<font class="keywordtype">void</font>);
02690   void     (*cond_signal)     (GCond        *cond);
02691   void     (*cond_broadcast)  (GCond        *cond);
02692   void     (*cond_wait)       (GCond        *cond,
02693                    GMutex       *mutex);
02694   gboolean (*cond_timed_wait) (GCond        *cond,
02695                    GMutex       *mutex, 
02696                    GTimeVal     *end_time);
02697   void      (*cond_free)      (GCond        *cond);
02698   GPrivate* (*private_new)    (GDestroyNotify    destructor);
02699   gpointer  (*private_get)    (GPrivate     *private_key);
02700   void      (*private_set)    (GPrivate     *private_key,
02701                    gpointer      data);
02702 };
02703 
02704 GUTILS_C_VAR GThreadFunctions   g_thread_functions_for_glib_use;
02705 GUTILS_C_VAR gboolean       g_thread_use_default_impl;
02706 GUTILS_C_VAR gboolean       g_threads_got_initialized;
02707 
02708 <font class="comment">/* initializes the mutex/cond/private implementation for glib, might</font>
02709 <font class="comment"> * only be called once, and must not be called directly or indirectly</font>
02710 <font class="comment"> * from another glib-function, e.g. as a callback.</font>
02711 <font class="comment"> */</font>
02712 <font class="keywordtype">void</font>   g_thread_init   (GThreadFunctions       *vtable);
02713 
02714 <font class="comment">/* internal function for fallback static mutex implementation */</font>
02715 GMutex* g_static_mutex_get_mutex_impl   (GMutex **mutex);
02716 
02717 <font class="comment">/* shorthands for conditional and unconditional function calls */</font>
02718 <font class="preprocessor">#define G_THREAD_UF(name, arglist) \</font>
02719 <font class="preprocessor">    (*g_thread_functions_for_glib_use . name) arglist</font>
02720 <font class="preprocessor"></font><font class="preprocessor">#define G_THREAD_CF(name, fail, arg) \</font>
02721 <font class="preprocessor">    (g_thread_supported () ? G_THREAD_UF (name, arg) : (fail))</font>
02722 <font class="preprocessor"></font><font class="comment">/* keep in mind, all those mutexes and static mutexes are not </font>
02723 <font class="comment"> * recursive in general, don't rely on that</font>
02724 <font class="comment"> */</font>
02725 <font class="preprocessor">#define g_thread_supported()    (g_threads_got_initialized)</font>
02726 <font class="preprocessor"></font><font class="preprocessor">#define g_mutex_new()            G_THREAD_UF (mutex_new,      ())</font>
02727 <font class="preprocessor"></font><font class="preprocessor">#define g_mutex_lock(mutex)      G_THREAD_CF (mutex_lock,     (void)0, (mutex))</font>
02728 <font class="preprocessor"></font><font class="preprocessor">#define g_mutex_trylock(mutex)   G_THREAD_CF (mutex_trylock,  TRUE,    (mutex))</font>
02729 <font class="preprocessor"></font><font class="preprocessor">#define g_mutex_unlock(mutex)    G_THREAD_CF (mutex_unlock,   (void)0, (mutex))</font>
02730 <font class="preprocessor"></font><font class="preprocessor">#define g_mutex_free(mutex)      G_THREAD_CF (mutex_free,     (void)0, (mutex))</font>
02731 <font class="preprocessor"></font><font class="preprocessor">#define g_cond_new()             G_THREAD_UF (cond_new,       ())</font>
02732 <font class="preprocessor"></font><font class="preprocessor">#define g_cond_signal(cond)      G_THREAD_CF (cond_signal,    (void)0, (cond))</font>
02733 <font class="preprocessor"></font><font class="preprocessor">#define g_cond_broadcast(cond)   G_THREAD_CF (cond_broadcast, (void)0, (cond))</font>
02734 <font class="preprocessor"></font><font class="preprocessor">#define g_cond_wait(cond, mutex) G_THREAD_CF (cond_wait,      (void)0, (cond, \</font>
02735 <font class="preprocessor">                                                                        mutex))</font>
02736 <font class="preprocessor"></font><font class="preprocessor">#define g_cond_free(cond)        G_THREAD_CF (cond_free,      (void)0, (cond))</font>
02737 <font class="preprocessor"></font><font class="preprocessor">#define g_cond_timed_wait(cond, mutex, abs_time) G_THREAD_CF (cond_timed_wait, \</font>
02738 <font class="preprocessor">                                                              TRUE, \</font>
02739 <font class="preprocessor">                                                              (cond, mutex, \</font>
02740 <font class="preprocessor">                                   abs_time))</font>
02741 <font class="preprocessor"></font><font class="preprocessor">#define g_private_new(destructor)     G_THREAD_UF (private_new, (destructor))</font>
02742 <font class="preprocessor"></font><font class="preprocessor">#define g_private_get(private_key)    G_THREAD_CF (private_get, \</font>
02743 <font class="preprocessor">                                                       ((gpointer)private_key), \</font>
02744 <font class="preprocessor">                                                       (private_key))</font>
02745 <font class="preprocessor"></font><font class="preprocessor">#define g_private_set(private_key, value) G_THREAD_CF (private_set, \</font>
02746 <font class="preprocessor">                                                       (void) (private_key = \</font>
02747 <font class="preprocessor">                                                        (GPrivate*) (value)), \</font>
02748 <font class="preprocessor">                                                       (private_key, value))</font>
02749 <font class="preprocessor"></font><font class="comment">/* GStaticMutexes can be statically initialized with the value</font>
02750 <font class="comment"> * G_STATIC_MUTEX_INIT, and then they can directly be used, that is</font>
02751 <font class="comment"> * much easier, than having to explicitly allocate the mutex before</font>
02752 <font class="comment"> * use</font>
02753 <font class="comment"> */</font>
02754 <font class="preprocessor">#define g_static_mutex_lock(mutex) \</font>
02755 <font class="preprocessor">    g_mutex_lock (g_static_mutex_get_mutex (mutex))</font>
02756 <font class="preprocessor"></font><font class="preprocessor">#define g_static_mutex_trylock(mutex) \</font>
02757 <font class="preprocessor">    g_mutex_trylock (g_static_mutex_get_mutex (mutex))</font>
02758 <font class="preprocessor"></font><font class="preprocessor">#define g_static_mutex_unlock(mutex) \</font>
02759 <font class="preprocessor">    g_mutex_unlock (g_static_mutex_get_mutex (mutex)) </font>
02760 <font class="preprocessor"></font><font class="keyword">struct </font>_GStaticPrivate
02761 {
02762   guint index;
02763 };
02764 <font class="preprocessor">#define G_STATIC_PRIVATE_INIT { 0 }</font>
02765 <font class="preprocessor"></font>gpointer g_static_private_get (GStaticPrivate   *private_key);
02766 <font class="keywordtype">void</font>     g_static_private_set (GStaticPrivate   *private_key, 
02767                    gpointer          data,
02768                    GDestroyNotify    notify);
02769 
02770 <font class="comment">/* these are some convenience macros that expand to nothing if GLib</font>
02771 <font class="comment"> * was configured with --disable-threads. for using StaticMutexes,</font>
02772 <font class="comment"> * you define them with G_LOCK_DEFINE_STATIC (name) or G_LOCK_DEFINE (name)</font>
02773 <font class="comment"> * if you need to export the mutex. With G_LOCK_EXTERN (name) you can</font>
02774 <font class="comment"> * declare such an globally defined lock. name is a unique identifier</font>
02775 <font class="comment"> * for the protected varibale or code portion. locking, testing and</font>
02776 <font class="comment"> * unlocking of such mutexes can be done with G_LOCK(), G_UNLOCK() and</font>
02777 <font class="comment"> * G_TRYLOCK() respectively.  </font>
02778 <font class="comment"> */</font>
02779 <font class="keyword">extern</font> <font class="keywordtype">void</font> glib_dummy_decl (<font class="keywordtype">void</font>);
02780 <font class="preprocessor">#define G_LOCK_NAME(name)       (g__ ## name ## _lock)</font>
02781 <font class="preprocessor"></font><font class="preprocessor">#ifdef  G_THREADS_ENABLED</font>
02782 <font class="preprocessor"></font><font class="preprocessor">#  define G_LOCK_DEFINE_STATIC(name)    static G_LOCK_DEFINE (name)</font>
02783 <font class="preprocessor"></font><font class="preprocessor">#  define G_LOCK_DEFINE(name)       \</font>
02784 <font class="preprocessor">    GStaticMutex G_LOCK_NAME (name) = G_STATIC_MUTEX_INIT </font>
02785 <font class="preprocessor"></font><font class="preprocessor">#  define G_LOCK_EXTERN(name)       extern GStaticMutex G_LOCK_NAME (name)</font>
02786 <font class="preprocessor"></font>
02787 <font class="preprocessor">#  ifdef G_DEBUG_LOCKS</font>
02788 <font class="preprocessor"></font><font class="preprocessor">#    define G_LOCK(name)        G_STMT_START{         \</font>
02789 <font class="preprocessor">        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,           \</font>
02790 <font class="preprocessor">           "file %s: line %d (%s): locking: %s ",             \</font>
02791 <font class="preprocessor">           __FILE__,    __LINE__, G_GNUC_PRETTY_FUNCTION, \</font>
02792 <font class="preprocessor">               #name);                                            \</font>
02793 <font class="preprocessor">        g_static_mutex_lock (&amp;G_LOCK_NAME (name));                \</font>
02794 <font class="preprocessor">     }G_STMT_END</font>
02795 <font class="preprocessor"></font><font class="preprocessor">#    define G_UNLOCK(name)      G_STMT_START{         \</font>
02796 <font class="preprocessor">        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,           \</font>
02797 <font class="preprocessor">           "file %s: line %d (%s): unlocking: %s ",           \</font>
02798 <font class="preprocessor">           __FILE__,    __LINE__, G_GNUC_PRETTY_FUNCTION, \</font>
02799 <font class="preprocessor">               #name);                                            \</font>
02800 <font class="preprocessor">       g_static_mutex_unlock (&amp;G_LOCK_NAME (name));               \</font>
02801 <font class="preprocessor">     }G_STMT_END</font>
02802 <font class="preprocessor"></font><font class="preprocessor">#    define G_TRYLOCK(name)     G_STMT_START{         \</font>
02803 <font class="preprocessor">        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,           \</font>
02804 <font class="preprocessor">           "file %s: line %d (%s): try locking: %s ",         \</font>
02805 <font class="preprocessor">           __FILE__,    __LINE__, G_GNUC_PRETTY_FUNCTION, \</font>
02806 <font class="preprocessor">               #name);                                            \</font>
02807 <font class="preprocessor">     }G_STMT_END,   g_static_mutex_trylock (&amp;G_LOCK_NAME (name))</font>
02808 <font class="preprocessor"></font><font class="preprocessor">#  else  </font><font class="comment">/* !G_DEBUG_LOCKS */</font>
02809 <font class="preprocessor">#    define G_LOCK(name) g_static_mutex_lock       (&amp;G_LOCK_NAME (name)) </font>
02810 <font class="preprocessor"></font><font class="preprocessor">#    define G_UNLOCK(name) g_static_mutex_unlock   (&amp;G_LOCK_NAME (name))</font>
02811 <font class="preprocessor"></font><font class="preprocessor">#    define G_TRYLOCK(name) g_static_mutex_trylock (&amp;G_LOCK_NAME (name))</font>
02812 <font class="preprocessor"></font><font class="preprocessor">#  endif </font><font class="comment">/* !G_DEBUG_LOCKS */</font>
02813 <font class="preprocessor">#else   </font><font class="comment">/* !G_THREADS_ENABLED */</font>
02814 <font class="preprocessor">#  define G_LOCK_DEFINE_STATIC(name)    extern void glib_dummy_decl (void)</font>
02815 <font class="preprocessor"></font><font class="preprocessor">#  define G_LOCK_DEFINE(name)       extern void glib_dummy_decl (void)</font>
02816 <font class="preprocessor"></font><font class="preprocessor">#  define G_LOCK_EXTERN(name)       extern void glib_dummy_decl (void)</font>
02817 <font class="preprocessor"></font><font class="preprocessor">#  define G_LOCK(name)</font>
02818 <font class="preprocessor"></font><font class="preprocessor">#  define G_UNLOCK(name)</font>
02819 <font class="preprocessor"></font><font class="preprocessor">#  define G_TRYLOCK(name)       (FALSE)</font>
02820 <font class="preprocessor"></font><font class="preprocessor">#endif  </font><font class="comment">/* !G_THREADS_ENABLED */</font>
02821 
02822 <font class="preprocessor">#ifdef __cplusplus</font>
02823 <font class="preprocessor"></font>}
02824 <font class="preprocessor">#endif </font><font class="comment">/* __cplusplus */</font>
02825 
02826 
02827 <font class="preprocessor">#endif </font><font class="comment">/* __G_LIB_H__ */</font>
</pre></div><hr><address><small>Generated at Fri Feb 15 20:17:51 2002 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
